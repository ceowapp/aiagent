/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-xarrows";
exports.ids = ["vendor-chunks/react-xarrows"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-xarrows/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-xarrows/lib/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\"), __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_lodash__, __WEBPACK_EXTERNAL_MODULE_prop_types__) {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/Xarrow/utils/buzzier.js\":\n/*!*************************************!*\\\n  !*** ./src/Xarrow/utils/buzzier.js ***!\n  \\*************************************/\n/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1031__) {\n\n__nested_webpack_require_1031__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_1031__.d(__nested_webpack_exports__, {\n/* harmony export */   \"bzFunction\": function() { return /* binding */ bzFunction; },\n/* harmony export */   \"buzzierMinSols\": function() { return /* binding */ buzzierMinSols; }\n/* harmony export */ });\n// Buzier curve calculations\n\n/**\r\n * returns buzzier curve function with 2 controls points\r\n * bzCurve with 2 control points function(4 points total):  bz = (1−t)^3*p1 + 3(1−t)^2*t*p2 +3(1−t)*t^2*p3 + t^3*p4\r\n */\nvar bzFunction = function bzFunction(p1, p2, p3, p4) {\n  return function (t) {\n    return Math.pow(1 - t, 3) * p1 + 3 * Math.pow(1 - t, 2) * t * p2 + 3 * (1 - t) * Math.pow(t, 2) * p3 + Math.pow(t, 3) * p4;\n  };\n};\n/**\r\n * returns 2 solutions from extram points for buzzier curve with 2 controls points\r\n */\n\nvar buzzierMinSols = function buzzierMinSols(p1, p2, p3, p4) {\n  var bz = bzFunction(p1, p2, p3, p4); // dt(bz) = -3 p1 (1 - t)^2 + 3 p2 (1 - t)^2 - 6 p2 (1 - t) t + 6 p3 (1 - t) t - 3 p3 t^2 + 3 p4 t^2\n  // when p1=(x1,y1),p2=(cpx1,cpy1),p3=(cpx2,cpy2),p4=(x2,y2)\n  // then extrema points is when dt(bz) = 0\n  // solutions =>  t = ((-6 p1 + 12 p2 - 6 p3) ± sqrt((6 p1 - 12 p2 + 6 p3)^2 - 4 (3 p2 - 3 p1) (-3 p1 + 9 p2 - 9 p3 + 3 p4)))/(2 (-3 p1 + 9 p2 - 9 p3 + 3 p4))  when (p1 + 3 p3!=3 p2 + p4)\n  // if we mark A=(-6 p1 + 12 p2 - 6 p3) and B=(6 p1 - 12 p2 + 6 p3)^2 - 4 (3 p2 - 3 p1) (-3 p1 + 9 p2 - 9 p3 + 3 p4)) and C =(2 (-3 p1 + 9 p2 - 9 p3 + 3 p4) then\n  // tSol = A ± sqrt(B)\n  // then solution we want is: bz(tSol)\n\n  var A = -6 * p1 + 12 * p2 - 6 * p3;\n  var B = Math.pow(-6 * p1 + 12 * p2 - 6 * p3, 2) - 4 * (3 * p2 - 3 * p1) * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4);\n  var C = 2 * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4);\n  var sol1 = bz((A + Math.sqrt(B)) / C);\n  var sol2 = bz((A - Math.sqrt(B)) / C);\n  return [sol1, sol2];\n};\n\n/***/ }),\n\n/***/ \"./src/Xarrow/Xarrow.tsx\":\n/*!*******************************!*\\\n  !*** ./src/Xarrow/Xarrow.tsx ***!\n  \\*******************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_3135__) {\n\n\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar react_1 = __importStar(__nested_webpack_require_3135__(/*! react */ \"react\"));\r\nvar useXarrowProps_1 = __importDefault(__nested_webpack_require_3135__(/*! ./useXarrowProps */ \"./src/Xarrow/useXarrowProps.ts\"));\r\nvar Xwrapper_1 = __nested_webpack_require_3135__(/*! ../Xwrapper */ \"./src/Xwrapper.tsx\");\r\nvar propTypes_1 = __importDefault(__nested_webpack_require_3135__(/*! ./propTypes */ \"./src/Xarrow/propTypes.ts\"));\r\nvar GetPosition_1 = __nested_webpack_require_3135__(/*! ./utils/GetPosition */ \"./src/Xarrow/utils/GetPosition.tsx\");\r\nvar log = console.log;\r\nvar Xarrow = function (props) {\r\n    // log('xarrow update');\r\n    var _a;\r\n    var mainRef = react_1.useRef({\r\n        svgRef: react_1.useRef(null),\r\n        lineRef: react_1.useRef(null),\r\n        headRef: react_1.useRef(null),\r\n        tailRef: react_1.useRef(null),\r\n        lineDrawAnimRef: react_1.useRef(null),\r\n        lineDashAnimRef: react_1.useRef(null),\r\n        headOpacityAnimRef: react_1.useRef(null),\r\n    });\r\n    var _b = mainRef.current, svgRef = _b.svgRef, lineRef = _b.lineRef, headRef = _b.headRef, tailRef = _b.tailRef, lineDrawAnimRef = _b.lineDrawAnimRef, lineDashAnimRef = _b.lineDashAnimRef, headOpacityAnimRef = _b.headOpacityAnimRef;\r\n    react_1.useContext(Xwrapper_1.XarrowContext);\r\n    var xProps = useXarrowProps_1.default(props, mainRef.current);\r\n    var propsRefs = xProps[0];\r\n    var labels = propsRefs.labels, lineColor = propsRefs.lineColor, headColor = propsRefs.headColor, tailColor = propsRefs.tailColor, strokeWidth = propsRefs.strokeWidth, showHead = propsRefs.showHead, showTail = propsRefs.showTail, dashness = propsRefs.dashness, headShape = propsRefs.headShape, tailShape = propsRefs.tailShape, showXarrow = propsRefs.showXarrow, animateDrawing = propsRefs.animateDrawing, zIndex = propsRefs.zIndex, passProps = propsRefs.passProps, arrowBodyProps = propsRefs.arrowBodyProps, arrowHeadProps = propsRefs.arrowHeadProps, arrowTailProps = propsRefs.arrowTailProps, SVGcanvasProps = propsRefs.SVGcanvasProps, divContainerProps = propsRefs.divContainerProps, divContainerStyle = propsRefs.divContainerStyle, SVGcanvasStyle = propsRefs.SVGcanvasStyle, _debug = propsRefs._debug, shouldUpdatePosition = propsRefs.shouldUpdatePosition;\r\n    animateDrawing = props.animateDrawing;\r\n    var _c = react_1.useState(!animateDrawing), drawAnimEnded = _c[0], setDrawAnimEnded = _c[1];\r\n    var _d = react_1.useState({}), setRender = _d[1];\r\n    var forceRerender = function () { return setRender({}); };\r\n    var _e = react_1.useState({\r\n        //initial state\r\n        cx0: 0,\r\n        cy0: 0,\r\n        cw: 0,\r\n        ch: 0,\r\n        x1: 0,\r\n        y1: 0,\r\n        x2: 0,\r\n        y2: 0,\r\n        dx: 0,\r\n        dy: 0,\r\n        absDx: 0,\r\n        absDy: 0,\r\n        cpx1: 0,\r\n        cpy1: 0,\r\n        cpx2: 0,\r\n        cpy2: 0,\r\n        headOrient: 0,\r\n        tailOrient: 0,\r\n        arrowHeadOffset: { x: 0, y: 0 },\r\n        arrowTailOffset: { x: 0, y: 0 },\r\n        headOffset: 0,\r\n        excRight: 0,\r\n        excLeft: 0,\r\n        excUp: 0,\r\n        excDown: 0,\r\n        startPoints: [],\r\n        endPoints: [],\r\n        mainDivPos: { x: 0, y: 0 },\r\n        xSign: 1,\r\n        ySign: 1,\r\n        lineLength: 0,\r\n        fHeadSize: 1,\r\n        fTailSize: 1,\r\n        arrowPath: \"\",\r\n        labelStartPos: { x: 0, y: 0 },\r\n        labelMiddlePos: { x: 0, y: 0 },\r\n        labelEndPos: { x: 0, y: 0 },\r\n    }), st = _e[0], setSt = _e[1];\r\n    /**\r\n     * The Main logic of path calculation for the arrow.\r\n     * calculate new path, adjusting canvas, and set state based on given properties.\r\n     * */\r\n    react_1.useLayoutEffect(function () {\r\n        if (shouldUpdatePosition.current) {\r\n            // log('xarrow getPosition');\r\n            var pos = GetPosition_1.getPosition(xProps, mainRef);\r\n            // log('pos', pos);\r\n            setSt(pos);\r\n            shouldUpdatePosition.current = false;\r\n        }\r\n    });\r\n    // log('st', st);\r\n    var xOffsetHead = st.x2 - st.arrowHeadOffset.x;\r\n    var yOffsetHead = st.y2 - st.arrowHeadOffset.y;\r\n    var xOffsetTail = st.x1 - st.arrowTailOffset.x;\r\n    var yOffsetTail = st.y1 - st.arrowTailOffset.y;\r\n    var dashoffset = dashness.strokeLen + dashness.nonStrokeLen;\r\n    var animDirection = 1;\r\n    if (dashness.animation < 0) {\r\n        dashness.animation *= -1;\r\n        animDirection = -1;\r\n    }\r\n    var dashArray, animation, animRepeatCount, animStartValue, animEndValue = 0;\r\n    if (animateDrawing && drawAnimEnded == false) {\r\n        if (typeof animateDrawing === 'boolean')\r\n            animateDrawing = 1;\r\n        animation = animateDrawing + 's';\r\n        dashArray = st.lineLength;\r\n        animStartValue = st.lineLength;\r\n        animRepeatCount = 1;\r\n        if (animateDrawing < 0) {\r\n            _a = [animEndValue, animStartValue], animStartValue = _a[0], animEndValue = _a[1];\r\n            animation = animateDrawing * -1 + 's';\r\n        }\r\n    }\r\n    else {\r\n        dashArray = dashness.strokeLen + \" \" + dashness.nonStrokeLen;\r\n        animation = 1 / dashness.animation + \"s\";\r\n        animStartValue = dashoffset * animDirection;\r\n        animRepeatCount = 'indefinite';\r\n        animEndValue = 0;\r\n    }\r\n    // handle draw animation\r\n    react_1.useLayoutEffect(function () {\r\n        if (lineRef.current)\r\n            setSt(function (prevSt) { var _a, _b; return (__assign(__assign({}, prevSt), { lineLength: (_b = (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.getTotalLength()) !== null && _b !== void 0 ? _b : 0 })); });\r\n    }, [lineRef.current]);\r\n    // set all props on first render\r\n    react_1.useEffect(function () {\r\n        var monitorDOMchanges = function () {\r\n            window.addEventListener('resize', forceRerender);\r\n            var handleDrawAmimEnd = function () {\r\n                var _a, _b;\r\n                setDrawAnimEnded(true);\r\n                // @ts-ignore\r\n                (_a = headOpacityAnimRef.current) === null || _a === void 0 ? void 0 : _a.beginElement();\r\n                // @ts-ignore\r\n                (_b = lineDashAnimRef.current) === null || _b === void 0 ? void 0 : _b.beginElement();\r\n            };\r\n            var handleDrawAmimBegin = function () { return (headRef.current.style.opacity = '0'); };\r\n            if (lineDrawAnimRef.current && headRef.current) {\r\n                lineDrawAnimRef.current.addEventListener('endEvent', handleDrawAmimEnd);\r\n                lineDrawAnimRef.current.addEventListener('beginEvent', handleDrawAmimBegin);\r\n            }\r\n            return function () {\r\n                window.removeEventListener('resize', forceRerender);\r\n                if (lineDrawAnimRef.current) {\r\n                    lineDrawAnimRef.current.removeEventListener('endEvent', handleDrawAmimEnd);\r\n                    if (headRef.current)\r\n                        lineDrawAnimRef.current.removeEventListener('beginEvent', handleDrawAmimBegin);\r\n                }\r\n            };\r\n        };\r\n        var cleanMonitorDOMchanges = monitorDOMchanges();\r\n        return function () {\r\n            setDrawAnimEnded(false);\r\n            cleanMonitorDOMchanges();\r\n        };\r\n    }, [showXarrow]);\r\n    //todo: could make some advanced generic typescript inferring. for example get type from headShape.elem:T and\r\n    // tailShape.elem:K force the type for passProps,arrowHeadProps,arrowTailProps property. for now `as any` is used to\r\n    // avoid typescript conflicts\r\n    // so todo- fix all the `passProps as any` assertions\r\n    return (react_1.default.createElement(\"div\", __assign({}, divContainerProps, { style: __assign({ position: 'absolute', zIndex: zIndex }, divContainerStyle) }), showXarrow ? (react_1.default.createElement(react_1.default.Fragment, null,\r\n        react_1.default.createElement(\"svg\", __assign({ ref: svgRef, width: st.cw, height: st.ch, style: __assign({ position: 'absolute', left: st.cx0, top: st.cy0, pointerEvents: 'none', border: _debug ? '1px dashed yellow' : null }, SVGcanvasStyle), overflow: \"auto\" }, SVGcanvasProps),\r\n            react_1.default.createElement(\"path\", __assign({ ref: lineRef, d: st.arrowPath, stroke: lineColor, strokeDasharray: dashArray, \r\n                // strokeDasharray={'0 0'}\r\n                strokeWidth: strokeWidth, fill: \"transparent\", pointerEvents: \"visibleStroke\" }, passProps, arrowBodyProps),\r\n                react_1.default.createElement(react_1.default.Fragment, null, drawAnimEnded ? (react_1.default.createElement(react_1.default.Fragment, null, dashness.animation ? (react_1.default.createElement(\"animate\", { ref: lineDashAnimRef, attributeName: \"stroke-dashoffset\", values: dashoffset * animDirection + \";0\", dur: 1 / dashness.animation + \"s\", repeatCount: \"indefinite\" })) : null)) : (react_1.default.createElement(react_1.default.Fragment, null, animateDrawing ? (react_1.default.createElement(\"animate\", { ref: lineDrawAnimRef, id: \"svgEndAnimate\", attributeName: \"stroke-dashoffset\", values: animStartValue + \";\" + animEndValue, dur: animation, repeatCount: animRepeatCount })) : null)))),\r\n            showTail ? (react_1.default.createElement(\"g\", __assign({ fill: tailColor, pointerEvents: \"auto\", transform: \"translate(\" + xOffsetTail + \",\" + yOffsetTail + \") rotate(\" + st.tailOrient + \") scale(\" + st.fTailSize + \")\" }, passProps, arrowTailProps), tailShape.svgElem)) : null,\r\n            showHead ? (react_1.default.createElement(\"g\", __assign({ ref: headRef, \r\n                // d={normalArrowShape}\r\n                fill: headColor, pointerEvents: \"auto\", transform: \"translate(\" + xOffsetHead + \",\" + yOffsetHead + \") rotate(\" + st.headOrient + \") scale(\" + st.fHeadSize + \")\", opacity: animateDrawing && !drawAnimEnded ? 0 : 1 }, passProps, arrowHeadProps),\r\n                react_1.default.createElement(\"animate\", { ref: headOpacityAnimRef, dur: '0.4', attributeName: \"opacity\", from: \"0\", to: \"1\", begin: \"indefinite\", repeatCount: \"0\", fill: \"freeze\" }),\r\n                headShape.svgElem)) : null,\r\n            _debug ? (react_1.default.createElement(react_1.default.Fragment, null,\r\n                react_1.default.createElement(\"circle\", { r: \"5\", cx: st.cpx1, cy: st.cpy1, fill: \"green\" }),\r\n                react_1.default.createElement(\"circle\", { r: \"5\", cx: st.cpx2, cy: st.cpy2, fill: \"blue\" }),\r\n                react_1.default.createElement(\"rect\", { x: st.excLeft, y: st.excUp, width: st.absDx, height: st.absDy, fill: \"none\", stroke: \"pink\", strokeWidth: \"2px\" }))) : null),\r\n        labels.start ? (react_1.default.createElement(\"div\", { style: {\r\n                transform: st.dx < 0 ? 'translate(-100% , -50%)' : 'translate(-0% , -50%)',\r\n                width: 'max-content',\r\n                position: 'absolute',\r\n                left: st.cx0 + st.labelStartPos.x,\r\n                top: st.cy0 + st.labelStartPos.y - strokeWidth - 5,\r\n            } }, labels.start)) : null,\r\n        labels.middle ? (react_1.default.createElement(\"div\", { style: {\r\n                display: 'table',\r\n                width: 'max-content',\r\n                transform: 'translate(-50% , -50%)',\r\n                position: 'absolute',\r\n                left: st.cx0 + st.labelMiddlePos.x,\r\n                top: st.cy0 + st.labelMiddlePos.y,\r\n            } }, labels.middle)) : null,\r\n        labels.end ? (react_1.default.createElement(\"div\", { style: {\r\n                transform: st.dx > 0 ? 'translate(-100% , -50%)' : 'translate(-0% , -50%)',\r\n                width: 'max-content',\r\n                position: 'absolute',\r\n                left: st.cx0 + st.labelEndPos.x,\r\n                top: st.cy0 + st.labelEndPos.y + strokeWidth + 5,\r\n            } }, labels.end)) : null,\r\n        _debug ? (react_1.default.createElement(react_1.default.Fragment, null, __spreadArray(__spreadArray([], st.startPoints), st.endPoints).map(function (p, i) {\r\n            return (react_1.default.createElement(\"div\", { key: i, style: {\r\n                    background: 'gray',\r\n                    opacity: 0.5,\r\n                    borderRadius: '50%',\r\n                    transform: 'translate(-50%, -50%)',\r\n                    height: 5,\r\n                    width: 5,\r\n                    position: 'absolute',\r\n                    left: p.x - st.mainDivPos.x,\r\n                    top: p.y - st.mainDivPos.y,\r\n                } }));\r\n        }))) : null)) : null));\r\n};\r\n//////////////////////////////\r\n// propTypes\r\nXarrow.propTypes = propTypes_1.default;\r\nexports.default = Xarrow;\r\n\n\n/***/ }),\n\n/***/ \"./src/Xarrow/anchors.ts\":\n/*!*******************************!*\\\n  !*** ./src/Xarrow/anchors.ts ***!\n  \\*******************************/\n/***/ (function(module, exports, __nested_webpack_require_17429__) {\n\n/* module decorator */ module = __nested_webpack_require_17429__.nmd(module);\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.calcAnchors = void 0;\r\nvar getAnchorsDefaultOffsets = function (width, height) {\r\n    return {\r\n        middle: { x: width * 0.5, y: height * 0.5 },\r\n        left: { x: 0, y: height * 0.5 },\r\n        right: { x: width, y: height * 0.5 },\r\n        top: { x: width * 0.5, y: 0 },\r\n        bottom: { x: width * 0.5, y: height },\r\n    };\r\n};\r\nvar calcAnchors = function (anchors, anchorPos) {\r\n    // now prepare this list of anchors to object expected by the `getShortestLine` function\r\n    return anchors.map(function (anchor) {\r\n        var defsOffsets = getAnchorsDefaultOffsets(anchorPos.right - anchorPos.x, anchorPos.bottom - anchorPos.y);\r\n        var _a = defsOffsets[anchor.position], x = _a.x, y = _a.y;\r\n        return {\r\n            x: anchorPos.x + x + anchor.offset.x,\r\n            y: anchorPos.y + y + anchor.offset.y,\r\n            anchor: anchor,\r\n        };\r\n    });\r\n};\r\nexports.calcAnchors = calcAnchors;\r\nif (__nested_webpack_require_17429__.c[__nested_webpack_require_17429__.s] === module) {\r\n    // const res = parseAnchor(['auto'], {\r\n    //   x: 0,\r\n    //   y: 0,\r\n    //   bottom: 10,\r\n    //   right: 20,\r\n    // });\r\n    // console.log(res);\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./src/Xarrow/propTypes.ts\":\n/*!*********************************!*\\\n  !*** ./src/Xarrow/propTypes.ts ***!\n  \\*********************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_18954__) {\n\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar prop_types_1 = __importDefault(__nested_webpack_require_18954__(/*! prop-types */ \"prop-types\"));\r\nvar constants_1 = __nested_webpack_require_18954__(/*! ../constants */ \"./src/constants.tsx\");\r\nvar pAnchorPositionType = prop_types_1.default.oneOf(constants_1.cAnchorEdge);\r\nvar pAnchorCustomPositionType = prop_types_1.default.exact({\r\n    position: pAnchorPositionType.isRequired,\r\n    offset: prop_types_1.default.exact({\r\n        x: prop_types_1.default.number,\r\n        y: prop_types_1.default.number,\r\n    }).isRequired,\r\n});\r\nvar _pAnchorType = prop_types_1.default.oneOfType([pAnchorPositionType, pAnchorCustomPositionType]);\r\nvar pAnchorType = prop_types_1.default.oneOfType([_pAnchorType, prop_types_1.default.arrayOf(_pAnchorType)]);\r\nvar pRefType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.exact({ current: prop_types_1.default.any })]);\r\nvar _pLabelType = prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.string]);\r\nvar pLabelsType = prop_types_1.default.exact({\r\n    start: _pLabelType,\r\n    middle: _pLabelType,\r\n    end: _pLabelType,\r\n});\r\nvar pSvgEdgeShapeType = prop_types_1.default.oneOf(Object.keys(constants_1.arrowShapes));\r\n// const pSvgElemType = PT.oneOf(cSvgElems);\r\nvar pSvgElemType = prop_types_1.default.any;\r\nvar pSvgEdgeType = prop_types_1.default.oneOfType([\r\n    pSvgEdgeShapeType,\r\n    prop_types_1.default.exact({\r\n        svgElem: pSvgElemType,\r\n        offsetForward: prop_types_1.default.number,\r\n    }).isRequired,\r\n]);\r\nvar XarrowPropTypes = {\r\n    start: pRefType.isRequired,\r\n    end: pRefType.isRequired,\r\n    startAnchor: pAnchorType,\r\n    endAnchor: pAnchorType,\r\n    labels: prop_types_1.default.oneOfType([_pLabelType, pLabelsType]),\r\n    color: prop_types_1.default.string,\r\n    lineColor: prop_types_1.default.string,\r\n    showHead: prop_types_1.default.bool,\r\n    headColor: prop_types_1.default.string,\r\n    headSize: prop_types_1.default.number,\r\n    tailSize: prop_types_1.default.number,\r\n    tailColor: prop_types_1.default.string,\r\n    strokeWidth: prop_types_1.default.number,\r\n    showTail: prop_types_1.default.bool,\r\n    path: prop_types_1.default.oneOf(constants_1.cPaths),\r\n    showXarrow: prop_types_1.default.bool,\r\n    curveness: prop_types_1.default.number,\r\n    gridBreak: prop_types_1.default.string,\r\n    dashness: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.object]),\r\n    headShape: pSvgEdgeType,\r\n    tailShape: pSvgEdgeType,\r\n    animateDrawing: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.number]),\r\n    zIndex: prop_types_1.default.number,\r\n    passProps: prop_types_1.default.object,\r\n    arrowBodyProps: prop_types_1.default.object,\r\n    arrowHeadProps: prop_types_1.default.object,\r\n    arrowTailProps: prop_types_1.default.object,\r\n    SVGcanvasProps: prop_types_1.default.object,\r\n    divContainerProps: prop_types_1.default.object,\r\n    _extendSVGcanvas: prop_types_1.default.number,\r\n    _debug: prop_types_1.default.bool,\r\n    _cpx1Offset: prop_types_1.default.number,\r\n    _cpy1Offset: prop_types_1.default.number,\r\n    _cpx2Offset: prop_types_1.default.number,\r\n    _cpy2Offset: prop_types_1.default.number,\r\n};\r\nexports.default = XarrowPropTypes;\r\n\n\n/***/ }),\n\n/***/ \"./src/Xarrow/useXarrowProps.ts\":\n/*!**************************************!*\\\n  !*** ./src/Xarrow/useXarrowProps.ts ***!\n  \\**************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_22681__) {\n\n\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar react_1 = __importStar(__nested_webpack_require_22681__(/*! react */ \"react\"));\r\nvar utils_1 = __nested_webpack_require_22681__(/*! ./utils */ \"./src/Xarrow/utils/index.ts\");\r\nvar lodash_1 = __importDefault(__nested_webpack_require_22681__(/*! lodash */ \"lodash\"));\r\nvar constants_1 = __nested_webpack_require_22681__(/*! ../constants */ \"./src/constants.tsx\");\r\nvar parseLabels = function (label) {\r\n    var parsedLabel = { start: null, middle: null, end: null };\r\n    if (label) {\r\n        if (typeof label === 'string' || react_1.default.isValidElement(label))\r\n            parsedLabel.middle = label;\r\n        else {\r\n            for (var key in label) {\r\n                parsedLabel[key] = label[key];\r\n            }\r\n        }\r\n    }\r\n    return parsedLabel;\r\n};\r\nvar parseAnchor = function (anchor) {\r\n    // convert to array\r\n    var anchorChoice = Array.isArray(anchor) ? anchor : [anchor];\r\n    //convert to array of objects\r\n    var anchorChoice2 = anchorChoice.map(function (anchorChoice) {\r\n        if (typeof anchorChoice === 'string') {\r\n            return { position: anchorChoice };\r\n        }\r\n        else\r\n            return anchorChoice;\r\n    });\r\n    //remove any invalid anchor names\r\n    anchorChoice2 = anchorChoice2.filter(function (an) { return constants_1.cAnchorEdge.includes(an.position); });\r\n    if (anchorChoice2.length == 0)\r\n        anchorChoice2 = [{ position: 'auto' }];\r\n    //replace any 'auto' with ['left','right','bottom','top']\r\n    var autosAncs = anchorChoice2.filter(function (an) { return an.position === 'auto'; });\r\n    if (autosAncs.length > 0) {\r\n        anchorChoice2 = anchorChoice2.filter(function (an) { return an.position !== 'auto'; });\r\n        anchorChoice2.push.apply(anchorChoice2, autosAncs.flatMap(function (anchorObj) {\r\n            return ['left', 'right', 'top', 'bottom'].map(function (anchorName) {\r\n                return __assign(__assign({}, anchorObj), { position: anchorName });\r\n            });\r\n        }));\r\n    }\r\n    // default values\r\n    var anchorChoice3 = anchorChoice2.map(function (anchorChoice) {\r\n        if (typeof anchorChoice === 'object') {\r\n            var anchorChoiceCustom = anchorChoice;\r\n            if (!anchorChoiceCustom.position)\r\n                anchorChoiceCustom.position = 'auto';\r\n            if (!anchorChoiceCustom.offset)\r\n                anchorChoiceCustom.offset = { x: 0, y: 0 };\r\n            if (!anchorChoiceCustom.offset.y)\r\n                anchorChoiceCustom.offset.y = 0;\r\n            if (!anchorChoiceCustom.offset.x)\r\n                anchorChoiceCustom.offset.x = 0;\r\n            anchorChoiceCustom = anchorChoiceCustom;\r\n            return anchorChoiceCustom;\r\n        }\r\n        else\r\n            return anchorChoice;\r\n    });\r\n    return anchorChoice3;\r\n};\r\nvar parseDashness = function (dashness, props) {\r\n    var dashStroke = 0, dashNone = 0, animDashSpeed, animDirection = 1;\r\n    if (typeof dashness === 'object') {\r\n        dashStroke = dashness.strokeLen || props.strokeWidth * 2;\r\n        dashNone = dashness.strokeLen ? dashness.nonStrokeLen : props.strokeWidth;\r\n        animDashSpeed = dashness.animation ? dashness.animation : null;\r\n    }\r\n    else if (typeof dashness === 'boolean' && dashness) {\r\n        dashStroke = props.strokeWidth * 2;\r\n        dashNone = props.strokeWidth;\r\n        animDashSpeed = null;\r\n    }\r\n    return { strokeLen: dashStroke, nonStrokeLen: dashNone, animation: animDashSpeed, animDirection: animDirection };\r\n};\r\nvar parseEdgeShape = function (svgEdge) {\r\n    if (typeof svgEdge == 'string') {\r\n        if (svgEdge in constants_1.arrowShapes)\r\n            svgEdge = constants_1.arrowShapes[svgEdge];\r\n        else {\r\n            console.warn(\"'\" + svgEdge + \"' is not supported arrow shape. the supported arrow shapes is one of \" + constants_1.cArrowShapes + \".\\n           reverting to default shape.\");\r\n            svgEdge = constants_1.arrowShapes['arrow1'];\r\n        }\r\n    }\r\n    svgEdge = svgEdge;\r\n    if ((svgEdge === null || svgEdge === void 0 ? void 0 : svgEdge.offsetForward) === undefined)\r\n        svgEdge.offsetForward = 0.25;\r\n    if ((svgEdge === null || svgEdge === void 0 ? void 0 : svgEdge.svgElem) === undefined)\r\n        svgEdge.svgElem = 'path';\r\n    // if (svgEdge?.svgProps === undefined) svgEdge.svgProps = arrowShapes.arrow1.svgProps;\r\n    return svgEdge;\r\n};\r\nvar parseGridBreak = function (gridBreak) {\r\n    var resGridBreak = utils_1.xStr2absRelative(gridBreak);\r\n    if (!resGridBreak)\r\n        resGridBreak = { relative: 0.5, abs: 0 };\r\n    return resGridBreak;\r\n};\r\n/**\r\n * should be wrapped with any changed prop that is affecting the points path positioning\r\n * @param propVal\r\n * @param updateRef\r\n */\r\nvar withUpdate = function (propVal, updateRef) {\r\n    if (updateRef)\r\n        updateRef.current = true;\r\n    return propVal;\r\n};\r\nvar noParse = function (userProp) { return userProp; };\r\nvar noParseWithUpdatePos = function (userProp, _, updatePos) { return withUpdate(userProp, updatePos); };\r\nvar parseNumWithUpdatePos = function (userProp, _, updatePos) { return withUpdate(Number(userProp), updatePos); };\r\nvar parseNum = function (userProp) { return Number(userProp); };\r\nvar parsePropsFuncs = {\r\n    start: function (userProp) { return utils_1.getElementByPropGiven(userProp); },\r\n    end: function (userProp) { return utils_1.getElementByPropGiven(userProp); },\r\n    startAnchor: function (userProp, _, updatePos) { return withUpdate(parseAnchor(userProp), updatePos); },\r\n    endAnchor: function (userProp, _, updatePos) { return withUpdate(parseAnchor(userProp), updatePos); },\r\n    labels: function (userProp) { return parseLabels(userProp); },\r\n    color: noParse,\r\n    lineColor: function (userProp, propsRefs) { return userProp || propsRefs.color; },\r\n    headColor: function (userProp, propsRefs) { return userProp || propsRefs.color; },\r\n    tailColor: function (userProp, propsRefs) { return userProp || propsRefs.color; },\r\n    strokeWidth: parseNumWithUpdatePos,\r\n    showHead: noParseWithUpdatePos,\r\n    headSize: parseNumWithUpdatePos,\r\n    showTail: noParseWithUpdatePos,\r\n    tailSize: parseNumWithUpdatePos,\r\n    path: noParseWithUpdatePos,\r\n    curveness: parseNumWithUpdatePos,\r\n    gridBreak: function (userProp, _, updatePos) { return withUpdate(parseGridBreak(userProp), updatePos); },\r\n    // // gridRadius = strokeWidth * 2, //todo\r\n    dashness: function (userProp, propsRefs) { return parseDashness(userProp, propsRefs); },\r\n    headShape: function (userProp) { return parseEdgeShape(userProp); },\r\n    tailShape: function (userProp) { return parseEdgeShape(userProp); },\r\n    showXarrow: noParse,\r\n    animateDrawing: noParse,\r\n    zIndex: parseNum,\r\n    passProps: noParse,\r\n    arrowBodyProps: noParseWithUpdatePos,\r\n    arrowHeadProps: noParseWithUpdatePos,\r\n    arrowTailProps: noParseWithUpdatePos,\r\n    SVGcanvasProps: noParseWithUpdatePos,\r\n    divContainerProps: noParseWithUpdatePos,\r\n    divContainerStyle: noParseWithUpdatePos,\r\n    SVGcanvasStyle: noParseWithUpdatePos,\r\n    _extendSVGcanvas: noParseWithUpdatePos,\r\n    _debug: noParseWithUpdatePos,\r\n    _cpx1Offset: noParseWithUpdatePos,\r\n    _cpy1Offset: noParseWithUpdatePos,\r\n    _cpx2Offset: noParseWithUpdatePos,\r\n    _cpy2Offset: noParseWithUpdatePos,\r\n};\r\n//build dependencies\r\nvar propsDeps = {};\r\n//each prop depends on himself\r\nfor (var propName in parsePropsFuncs) {\r\n    propsDeps[propName] = [propName];\r\n}\r\n// 'lineColor', 'headColor', 'tailColor' props also depends on 'color' prop\r\nfor (var _i = 0, _a = ['lineColor', 'headColor', 'tailColor']; _i < _a.length; _i++) {\r\n    var propName = _a[_i];\r\n    propsDeps[propName].push('color');\r\n}\r\nvar parseGivenProps = function (props, propsRef) {\r\n    var _a;\r\n    for (var _i = 0, _b = Object.entries(props); _i < _b.length; _i++) {\r\n        var _c = _b[_i], name_1 = _c[0], val = _c[1];\r\n        propsRef[name_1] = (_a = parsePropsFuncs === null || parsePropsFuncs === void 0 ? void 0 : parsePropsFuncs[name_1]) === null || _a === void 0 ? void 0 : _a.call(parsePropsFuncs, val, propsRef);\r\n    }\r\n    return propsRef;\r\n};\r\nvar defaultProps = {\r\n    start: null,\r\n    end: null,\r\n    startAnchor: 'auto',\r\n    endAnchor: 'auto',\r\n    labels: null,\r\n    color: 'CornflowerBlue',\r\n    lineColor: null,\r\n    headColor: null,\r\n    tailColor: null,\r\n    strokeWidth: 4,\r\n    showHead: true,\r\n    headSize: 6,\r\n    showTail: false,\r\n    tailSize: 6,\r\n    path: 'smooth',\r\n    curveness: 0.8,\r\n    gridBreak: '50%',\r\n    // gridRadius : strokeWidth * 2, //todo\r\n    dashness: false,\r\n    headShape: 'arrow1',\r\n    tailShape: 'arrow1',\r\n    showXarrow: true,\r\n    animateDrawing: false,\r\n    zIndex: 0,\r\n    passProps: {},\r\n    arrowBodyProps: {},\r\n    arrowHeadProps: {},\r\n    arrowTailProps: {},\r\n    SVGcanvasProps: {},\r\n    divContainerProps: {},\r\n    divContainerStyle: {},\r\n    SVGcanvasStyle: {},\r\n    _extendSVGcanvas: 0,\r\n    _debug: false,\r\n    _cpx1Offset: 0,\r\n    _cpy1Offset: 0,\r\n    _cpx2Offset: 0,\r\n    _cpy2Offset: 0,\r\n};\r\nvar initialParsedProps = {};\r\ninitialParsedProps = parseGivenProps(defaultProps, initialParsedProps);\r\nvar initialValVars = {\r\n    startPos: { x: 0, y: 0, right: 0, bottom: 0 },\r\n    endPos: { x: 0, y: 0, right: 0, bottom: 0 },\r\n};\r\n// const parseAllProps = () => parseGivenProps(defaultProps, initialParsedProps);\r\nfunction deepCompareEquals(a, b) {\r\n    return lodash_1.default.isEqual(a, b);\r\n}\r\nfunction useDeepCompareMemoize(value) {\r\n    var ref = react_1.useRef();\r\n    // it can be done by using useMemo as well\r\n    // but useRef is rather cleaner and easier\r\n    if (!deepCompareEquals(value, ref.current)) {\r\n        ref.current = value;\r\n    }\r\n    return ref.current;\r\n}\r\nfunction useDeepCompareEffect(callback, dependencies) {\r\n    react_1.useLayoutEffect(callback, dependencies.map(useDeepCompareMemoize));\r\n}\r\n/**\r\n * smart hook that provides parsed props to Xarrow and will trigger rerender whenever given prop is changed.\r\n */\r\nvar useXarrowProps = function (userProps, refs) {\r\n    var _a = react_1.useState(initialParsedProps), propsRefs = _a[0], setPropsRefs = _a[1];\r\n    var shouldUpdatePosition = react_1.useRef(false);\r\n    // const _propsRefs = useRef(initialParsedProps);\r\n    // const propsRefs = _propsRefs.current;\r\n    propsRefs['shouldUpdatePosition'] = shouldUpdatePosition;\r\n    var curProps = __assign(__assign({}, defaultProps), userProps);\r\n    var _loop_1 = function (propName) {\r\n        react_1.useLayoutEffect(function () {\r\n            var _a;\r\n            propsRefs[propName] = (_a = parsePropsFuncs === null || parsePropsFuncs === void 0 ? void 0 : parsePropsFuncs[propName]) === null || _a === void 0 ? void 0 : _a.call(parsePropsFuncs, curProps[propName], propsRefs, shouldUpdatePosition);\r\n            // console.log('prop update:', propName, 'with value', propsRefs[propName]);\r\n            setPropsRefs(__assign({}, propsRefs));\r\n        }, propsDeps[propName].map(function (name) { return userProps[name]; }));\r\n    };\r\n    // react states the number of hooks per render must stay constant,\r\n    // this is ok we are using these hooks in a loop, because the number of props in defaultProps is constant,\r\n    // so the number of hook we will fire each render will always be the same.\r\n    // update the value of the ref that represents the corresponding prop\r\n    // for example: if given 'start' prop would change call getElementByPropGiven(props.start) and save value into propsRefs.start.current\r\n    // why to save refs to props parsed values? some of the props require relatively expensive computations(like 'start' and 'startAnchor').\r\n    // this will always run in the same order and THAT'S WAY ITS LEGAL\r\n    for (var propName in defaultProps) {\r\n        _loop_1(propName);\r\n    }\r\n    // rerender whenever position of start element or end element changes\r\n    var _b = react_1.useState(initialValVars), valVars = _b[0], setValVars = _b[1];\r\n    var startPos = utils_1.getElemPos(propsRefs.start);\r\n    useDeepCompareEffect(function () {\r\n        valVars.startPos = startPos;\r\n        shouldUpdatePosition.current = true;\r\n        setValVars(__assign({}, valVars));\r\n        // console.log('start update pos', startPos);\r\n    }, [startPos]);\r\n    var endPos = utils_1.getElemPos(propsRefs.end);\r\n    useDeepCompareEffect(function () {\r\n        valVars.endPos = endPos;\r\n        shouldUpdatePosition.current = true;\r\n        setValVars(__assign({}, valVars));\r\n        // console.log('end update pos', endPos);\r\n    }, [endPos]);\r\n    react_1.useLayoutEffect(function () {\r\n        // console.log('svg shape changed!');\r\n        shouldUpdatePosition.current = true;\r\n        setValVars(__assign({}, valVars));\r\n    }, [propsRefs.headShape.svgElem, propsRefs.tailShape.svgElem]);\r\n    return [propsRefs, valVars];\r\n};\r\nexports.default = useXarrowProps;\r\n\n\n/***/ }),\n\n/***/ \"./src/Xarrow/utils/GetPosition.tsx\":\n/*!******************************************!*\\\n  !*** ./src/Xarrow/utils/GetPosition.tsx ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_37193__) {\n\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getPosition = void 0;\r\nvar anchors_1 = __nested_webpack_require_37193__(/*! ../anchors */ \"./src/Xarrow/anchors.ts\");\r\nvar index_1 = __nested_webpack_require_37193__(/*! ./index */ \"./src/Xarrow/utils/index.ts\");\r\nvar lodash_1 = __importDefault(__nested_webpack_require_37193__(/*! lodash */ \"lodash\"));\r\nvar constants_1 = __nested_webpack_require_37193__(/*! ../../constants */ \"./src/constants.tsx\");\r\nvar buzzier_1 = __nested_webpack_require_37193__(/*! ./buzzier */ \"./src/Xarrow/utils/buzzier.js\");\r\n/**\r\n * The Main logic of path calculation for the arrow.\r\n * calculate new path, adjusting canvas, and set state based on given properties.\r\n * */\r\nvar getPosition = function (xProps, mainRef) {\r\n    var _a, _b;\r\n    var _c, _d;\r\n    var propsRefs = xProps[0], valVars = xProps[1];\r\n    var startAnchor = propsRefs.startAnchor, endAnchor = propsRefs.endAnchor, strokeWidth = propsRefs.strokeWidth, showHead = propsRefs.showHead, headSize = propsRefs.headSize, showTail = propsRefs.showTail, tailSize = propsRefs.tailSize, path = propsRefs.path, curveness = propsRefs.curveness, gridBreak = propsRefs.gridBreak, headShape = propsRefs.headShape, tailShape = propsRefs.tailShape, _extendSVGcanvas = propsRefs._extendSVGcanvas, _cpx1Offset = propsRefs._cpx1Offset, _cpy1Offset = propsRefs._cpy1Offset, _cpx2Offset = propsRefs._cpx2Offset, _cpy2Offset = propsRefs._cpy2Offset;\r\n    var startPos = valVars.startPos, endPos = valVars.endPos;\r\n    var _e = mainRef.current, svgRef = _e.svgRef, lineRef = _e.lineRef;\r\n    var headOrient = 0;\r\n    var tailOrient = 0;\r\n    // convert startAnchor and endAnchor to list of objects represents allowed anchors.\r\n    var startPoints = anchors_1.calcAnchors(startAnchor, startPos);\r\n    var endPoints = anchors_1.calcAnchors(endAnchor, endPos);\r\n    // choose the smallest path for 2 points from these possibilities.\r\n    var _f = index_1.getShortestLine(startPoints, endPoints), chosenStart = _f.chosenStart, chosenEnd = _f.chosenEnd;\r\n    var startAnchorPosition = chosenStart.anchor.position, endAnchorPosition = chosenEnd.anchor.position;\r\n    var startPoint = lodash_1.default.pick(chosenStart, ['x', 'y']), endPoint = lodash_1.default.pick(chosenEnd, ['x', 'y']);\r\n    var mainDivPos = index_1.getSvgPos(svgRef);\r\n    var cx0 = Math.min(startPoint.x, endPoint.x) - mainDivPos.x;\r\n    var cy0 = Math.min(startPoint.y, endPoint.y) - mainDivPos.y;\r\n    var dx = endPoint.x - startPoint.x;\r\n    var dy = endPoint.y - startPoint.y;\r\n    var absDx = Math.abs(endPoint.x - startPoint.x);\r\n    var absDy = Math.abs(endPoint.y - startPoint.y);\r\n    var xSign = dx > 0 ? 1 : -1;\r\n    var ySign = dy > 0 ? 1 : -1;\r\n    var _g = [headShape.offsetForward, tailShape.offsetForward], headOffset = _g[0], tailOffset = _g[1];\r\n    var fHeadSize = headSize * strokeWidth; //factored head size\r\n    var fTailSize = tailSize * strokeWidth; //factored head size\r\n    // const { current: _headBox } = headBox;\r\n    var xHeadOffset = 0;\r\n    var yHeadOffset = 0;\r\n    var xTailOffset = 0;\r\n    var yTailOffset = 0;\r\n    var _headOffset = fHeadSize * headOffset;\r\n    var _tailOffset = fTailSize * tailOffset;\r\n    var cu = Number(curveness);\r\n    // gridRadius = Number(gridRadius);\r\n    if (!constants_1.cPaths.includes(path))\r\n        path = 'smooth';\r\n    if (path === 'straight') {\r\n        cu = 0;\r\n        path = 'smooth';\r\n    }\r\n    var biggerSide = headSize > tailSize ? headSize : tailSize;\r\n    var _calc = strokeWidth + (strokeWidth * biggerSide) / 2;\r\n    var excRight = _calc;\r\n    var excLeft = _calc;\r\n    var excUp = _calc;\r\n    var excDown = _calc;\r\n    excLeft += Number(_extendSVGcanvas);\r\n    excRight += Number(_extendSVGcanvas);\r\n    excUp += Number(_extendSVGcanvas);\r\n    excDown += Number(_extendSVGcanvas);\r\n    ////////////////////////////////////\r\n    // arrow point to point calculations\r\n    var x1 = 0, x2 = absDx, y1 = 0, y2 = absDy;\r\n    if (dx < 0)\r\n        _a = [x2, x1], x1 = _a[0], x2 = _a[1];\r\n    if (dy < 0)\r\n        _b = [y2, y1], y1 = _b[0], y2 = _b[1];\r\n    ////////////////////////////////////\r\n    // arrow curviness and arrowhead placement calculations\r\n    if (cu === 0) {\r\n        // in case of straight path\r\n        var headAngel = Math.atan(absDy / absDx);\r\n        if (showHead) {\r\n            x2 -= fHeadSize * (1 - headOffset) * xSign * Math.cos(headAngel);\r\n            y2 -= fHeadSize * (1 - headOffset) * ySign * Math.sin(headAngel);\r\n            headAngel *= ySign;\r\n            if (xSign < 0)\r\n                headAngel = (Math.PI - headAngel * xSign) * xSign;\r\n            xHeadOffset = Math.cos(headAngel) * _headOffset - (Math.sin(headAngel) * fHeadSize) / 2;\r\n            yHeadOffset = (Math.cos(headAngel) * fHeadSize) / 2 + Math.sin(headAngel) * _headOffset;\r\n            headOrient = (headAngel * 180) / Math.PI;\r\n        }\r\n        var tailAngel = Math.atan(absDy / absDx);\r\n        if (showTail) {\r\n            x1 += fTailSize * (1 - tailOffset) * xSign * Math.cos(tailAngel);\r\n            y1 += fTailSize * (1 - tailOffset) * ySign * Math.sin(tailAngel);\r\n            tailAngel *= -ySign;\r\n            if (xSign > 0)\r\n                tailAngel = (Math.PI - tailAngel * xSign) * xSign;\r\n            xTailOffset = Math.cos(tailAngel) * _tailOffset - (Math.sin(tailAngel) * fTailSize) / 2;\r\n            yTailOffset = (Math.cos(tailAngel) * fTailSize) / 2 + Math.sin(tailAngel) * _tailOffset;\r\n            tailOrient = (tailAngel * 180) / Math.PI;\r\n        }\r\n    }\r\n    else {\r\n        // in case of smooth path\r\n        if (endAnchorPosition === 'middle') {\r\n            // in case a middle anchor is chosen for endAnchor choose from which side to attach to the middle of the element\r\n            if (absDx > absDy) {\r\n                endAnchorPosition = xSign ? 'left' : 'right';\r\n            }\r\n            else {\r\n                endAnchorPosition = ySign ? 'top' : 'bottom';\r\n            }\r\n        }\r\n        if (showHead) {\r\n            if (['left', 'right'].includes(endAnchorPosition)) {\r\n                xHeadOffset += _headOffset * xSign;\r\n                x2 -= fHeadSize * (1 - headOffset) * xSign; //same!\r\n                yHeadOffset += (fHeadSize * xSign) / 2;\r\n                if (endAnchorPosition === 'left') {\r\n                    headOrient = 0;\r\n                    if (xSign < 0)\r\n                        headOrient += 180;\r\n                }\r\n                else {\r\n                    headOrient = 180;\r\n                    if (xSign > 0)\r\n                        headOrient += 180;\r\n                }\r\n            }\r\n            else if (['top', 'bottom'].includes(endAnchorPosition)) {\r\n                xHeadOffset += (fHeadSize * -ySign) / 2;\r\n                yHeadOffset += _headOffset * ySign;\r\n                y2 -= fHeadSize * ySign - yHeadOffset;\r\n                if (endAnchorPosition === 'top') {\r\n                    headOrient = 270;\r\n                    if (ySign > 0)\r\n                        headOrient += 180;\r\n                }\r\n                else {\r\n                    headOrient = 90;\r\n                    if (ySign < 0)\r\n                        headOrient += 180;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (showTail && cu !== 0) {\r\n        if (['left', 'right'].includes(startAnchorPosition)) {\r\n            xTailOffset += _tailOffset * -xSign;\r\n            x1 += fTailSize * xSign + xTailOffset;\r\n            yTailOffset += -(fTailSize * xSign) / 2;\r\n            if (startAnchorPosition === 'left') {\r\n                tailOrient = 180;\r\n                if (xSign < 0)\r\n                    tailOrient += 180;\r\n            }\r\n            else {\r\n                tailOrient = 0;\r\n                if (xSign > 0)\r\n                    tailOrient += 180;\r\n            }\r\n        }\r\n        else if (['top', 'bottom'].includes(startAnchorPosition)) {\r\n            yTailOffset += _tailOffset * -ySign;\r\n            y1 += fTailSize * ySign + yTailOffset;\r\n            xTailOffset += (fTailSize * ySign) / 2;\r\n            if (startAnchorPosition === 'top') {\r\n                tailOrient = 90;\r\n                if (ySign > 0)\r\n                    tailOrient += 180;\r\n            }\r\n            else {\r\n                tailOrient = 270;\r\n                if (ySign < 0)\r\n                    tailOrient += 180;\r\n            }\r\n        }\r\n    }\r\n    var arrowHeadOffset = { x: xHeadOffset, y: yHeadOffset };\r\n    var arrowTailOffset = { x: xTailOffset, y: yTailOffset };\r\n    var cpx1 = x1, cpy1 = y1, cpx2 = x2, cpy2 = y2;\r\n    var curvesPossibilities = {};\r\n    if (path === 'smooth')\r\n        curvesPossibilities = {\r\n            hh: function () {\r\n                //horizontal - from right to left or the opposite\r\n                cpx1 += absDx * cu * xSign;\r\n                cpx2 -= absDx * cu * xSign;\r\n            },\r\n            vv: function () {\r\n                //vertical - from top to bottom or opposite\r\n                cpy1 += absDy * cu * ySign;\r\n                cpy2 -= absDy * cu * ySign;\r\n            },\r\n            hv: function () {\r\n                // start horizontally then vertically\r\n                // from v side to h side\r\n                cpx1 += absDx * cu * xSign;\r\n                cpy2 -= absDy * cu * ySign;\r\n            },\r\n            vh: function () {\r\n                // start vertically then horizontally\r\n                // from h side to v side\r\n                cpy1 += absDy * cu * ySign;\r\n                cpx2 -= absDx * cu * xSign;\r\n            },\r\n        };\r\n    else if (path === 'grid') {\r\n        curvesPossibilities = {\r\n            hh: function () {\r\n                cpx1 += (absDx * gridBreak.relative + gridBreak.abs) * xSign;\r\n                cpx2 -= (absDx * (1 - gridBreak.relative) - gridBreak.abs) * xSign;\r\n                if (showHead) {\r\n                    cpx1 -= ((fHeadSize * (1 - headOffset)) / 2) * xSign;\r\n                    cpx2 += ((fHeadSize * (1 - headOffset)) / 2) * xSign;\r\n                }\r\n                if (showTail) {\r\n                    cpx1 -= ((fTailSize * (1 - tailOffset)) / 2) * xSign;\r\n                    cpx2 += ((fTailSize * (1 - tailOffset)) / 2) * xSign;\r\n                }\r\n            },\r\n            vv: function () {\r\n                cpy1 += (absDy * gridBreak.relative + gridBreak.abs) * ySign;\r\n                cpy2 -= (absDy * (1 - gridBreak.relative) - gridBreak.abs) * ySign;\r\n                if (showHead) {\r\n                    cpy1 -= ((fHeadSize * (1 - headOffset)) / 2) * ySign;\r\n                    cpy2 += ((fHeadSize * (1 - headOffset)) / 2) * ySign;\r\n                }\r\n                if (showTail) {\r\n                    cpy1 -= ((fTailSize * (1 - tailOffset)) / 2) * ySign;\r\n                    cpy2 += ((fTailSize * (1 - tailOffset)) / 2) * ySign;\r\n                }\r\n            },\r\n            hv: function () {\r\n                cpx1 = x2;\r\n            },\r\n            vh: function () {\r\n                cpy1 = y2;\r\n            },\r\n        };\r\n    }\r\n    // smart select best curve for the current anchors\r\n    var selectedCurviness = '';\r\n    if (['left', 'right'].includes(startAnchorPosition))\r\n        selectedCurviness += 'h';\r\n    else if (['bottom', 'top'].includes(startAnchorPosition))\r\n        selectedCurviness += 'v';\r\n    else if (startAnchorPosition === 'middle')\r\n        selectedCurviness += 'm';\r\n    if (['left', 'right'].includes(endAnchorPosition))\r\n        selectedCurviness += 'h';\r\n    else if (['bottom', 'top'].includes(endAnchorPosition))\r\n        selectedCurviness += 'v';\r\n    else if (endAnchorPosition === 'middle')\r\n        selectedCurviness += 'm';\r\n    if (absDx > absDy)\r\n        selectedCurviness = selectedCurviness.replace(/m/g, 'h');\r\n    else\r\n        selectedCurviness = selectedCurviness.replace(/m/g, 'v');\r\n    curvesPossibilities[selectedCurviness]();\r\n    cpx1 += _cpx1Offset;\r\n    cpy1 += _cpy1Offset;\r\n    cpx2 += _cpx2Offset;\r\n    cpy2 += _cpy2Offset;\r\n    ////////////////////////////////////\r\n    // canvas smart size adjustments\r\n    var _h = buzzier_1.buzzierMinSols(x1, cpx1, cpx2, x2), xSol1 = _h[0], xSol2 = _h[1];\r\n    var _j = buzzier_1.buzzierMinSols(y1, cpy1, cpy2, y2), ySol1 = _j[0], ySol2 = _j[1];\r\n    if (xSol1 < 0)\r\n        excLeft += -xSol1;\r\n    if (xSol2 > absDx)\r\n        excRight += xSol2 - absDx;\r\n    if (ySol1 < 0)\r\n        excUp += -ySol1;\r\n    if (ySol2 > absDy)\r\n        excDown += ySol2 - absDy;\r\n    if (path === 'grid') {\r\n        excLeft += _calc;\r\n        excRight += _calc;\r\n        excUp += _calc;\r\n        excDown += _calc;\r\n    }\r\n    x1 += excLeft;\r\n    x2 += excLeft;\r\n    y1 += excUp;\r\n    y2 += excUp;\r\n    cpx1 += excLeft;\r\n    cpx2 += excLeft;\r\n    cpy1 += excUp;\r\n    cpy2 += excUp;\r\n    var cw = absDx + excLeft + excRight, ch = absDy + excUp + excDown;\r\n    cx0 -= excLeft;\r\n    cy0 -= excUp;\r\n    //labels\r\n    var bzx = buzzier_1.bzFunction(x1, cpx1, cpx2, x2);\r\n    var bzy = buzzier_1.bzFunction(y1, cpy1, cpy2, y2);\r\n    var labelStartPos = { x: bzx(0.01), y: bzy(0.01) };\r\n    var labelMiddlePos = { x: bzx(0.5), y: bzy(0.5) };\r\n    var labelEndPos = { x: bzx(0.99), y: bzy(0.99) };\r\n    var arrowPath;\r\n    if (path === 'grid') {\r\n        // todo: support gridRadius\r\n        //  arrowPath = `M ${x1} ${y1} L  ${cpx1 - 10} ${cpy1} a10,10 0 0 1 10,10\r\n        // L ${cpx2} ${cpy2 - 10} a10,10 0 0 0 10,10 L  ${x2} ${y2}`;\r\n        arrowPath = \"M \" + x1 + \" \" + y1 + \" L  \" + cpx1 + \" \" + cpy1 + \" L \" + cpx2 + \" \" + cpy2 + \" \" + x2 + \" \" + y2;\r\n    }\r\n    else if (path === 'smooth')\r\n        arrowPath = \"M \" + x1 + \" \" + y1 + \" C \" + cpx1 + \" \" + cpy1 + \", \" + cpx2 + \" \" + cpy2 + \", \" + x2 + \" \" + y2;\r\n    return {\r\n        cx0: cx0,\r\n        cy0: cy0,\r\n        x1: x1,\r\n        x2: x2,\r\n        y1: y1,\r\n        y2: y2,\r\n        cw: cw,\r\n        ch: ch,\r\n        cpx1: cpx1,\r\n        cpy1: cpy1,\r\n        cpx2: cpx2,\r\n        cpy2: cpy2,\r\n        dx: dx,\r\n        dy: dy,\r\n        absDx: absDx,\r\n        absDy: absDy,\r\n        headOrient: headOrient,\r\n        tailOrient: tailOrient,\r\n        labelStartPos: labelStartPos,\r\n        labelMiddlePos: labelMiddlePos,\r\n        labelEndPos: labelEndPos,\r\n        excLeft: excLeft,\r\n        excRight: excRight,\r\n        excUp: excUp,\r\n        excDown: excDown,\r\n        headOffset: _headOffset,\r\n        arrowHeadOffset: arrowHeadOffset,\r\n        arrowTailOffset: arrowTailOffset,\r\n        startPoints: startPoints,\r\n        endPoints: endPoints,\r\n        mainDivPos: mainDivPos,\r\n        xSign: xSign,\r\n        ySign: ySign,\r\n        lineLength: (_d = (_c = lineRef.current) === null || _c === void 0 ? void 0 : _c.getTotalLength()) !== null && _d !== void 0 ? _d : 0,\r\n        fHeadSize: fHeadSize,\r\n        fTailSize: fTailSize,\r\n        arrowPath: arrowPath,\r\n    };\r\n};\r\nexports.getPosition = getPosition;\r\n\n\n/***/ }),\n\n/***/ \"./src/Xarrow/utils/index.ts\":\n/*!***********************************!*\\\n  !*** ./src/Xarrow/utils/index.ts ***!\n  \\***********************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getSvgPos = exports.getElemPos = exports.getShortestLine = exports.xStr2absRelative = exports.factorDpathStr = exports.getElementByPropGiven = void 0;\r\nvar getElementByPropGiven = function (ref) {\r\n    var myRef;\r\n    if (typeof ref === 'string') {\r\n        // myRef = document.getElementById(ref);\r\n        myRef = document.getElementById(ref);\r\n    }\r\n    else\r\n        myRef = ref === null || ref === void 0 ? void 0 : ref.current;\r\n    return myRef;\r\n};\r\nexports.getElementByPropGiven = getElementByPropGiven;\r\n// receives string representing a d path and factoring only the numbers\r\nvar factorDpathStr = function (d, factor) {\r\n    var l = d.split(/(\\d+(?:\\.\\d+)?)/);\r\n    l = l.map(function (s) {\r\n        if (Number(s))\r\n            return (Number(s) * factor).toString();\r\n        else\r\n            return s;\r\n    });\r\n    return l.join('');\r\n};\r\nexports.factorDpathStr = factorDpathStr;\r\n// return relative,abs\r\nvar xStr2absRelative = function (str) {\r\n    if (typeof str !== 'string')\r\n        return { abs: 0, relative: 0.5 };\r\n    var sp = str.split('%');\r\n    var absLen = 0, percentLen = 0;\r\n    if (sp.length == 1) {\r\n        var p = parseFloat(sp[0]);\r\n        if (!isNaN(p)) {\r\n            absLen = p;\r\n            return { abs: absLen, relative: 0 };\r\n        }\r\n    }\r\n    else if (sp.length == 2) {\r\n        var _a = [parseFloat(sp[0]), parseFloat(sp[1])], p1 = _a[0], p2 = _a[1];\r\n        if (!isNaN(p1))\r\n            percentLen = p1 / 100;\r\n        if (!isNaN(p2))\r\n            absLen = p2;\r\n        if (!isNaN(p1) || !isNaN(p2))\r\n            return { abs: absLen, relative: percentLen };\r\n    }\r\n};\r\nexports.xStr2absRelative = xStr2absRelative;\r\nvar dist = function (p1, p2) {\r\n    //length of line\r\n    return Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2));\r\n};\r\nvar getShortestLine = function (sPoints, ePoints) {\r\n    // closes tPair Of Points which feet to the specified anchors\r\n    var minDist = Infinity, d = Infinity;\r\n    var closestPair;\r\n    sPoints.forEach(function (sp) {\r\n        ePoints.forEach(function (ep) {\r\n            d = dist(sp, ep);\r\n            if (d < minDist) {\r\n                minDist = d;\r\n                closestPair = { chosenStart: sp, chosenEnd: ep };\r\n            }\r\n        });\r\n    });\r\n    return closestPair;\r\n};\r\nexports.getShortestLine = getShortestLine;\r\nvar getElemPos = function (elem) {\r\n    if (!elem)\r\n        return { x: 0, y: 0, right: 0, bottom: 0 };\r\n    var pos = elem.getBoundingClientRect();\r\n    return {\r\n        x: pos.left,\r\n        y: pos.top,\r\n        right: pos.right,\r\n        bottom: pos.bottom,\r\n    };\r\n};\r\nexports.getElemPos = getElemPos;\r\nvar getSvgPos = function (svgRef) {\r\n    if (!svgRef.current)\r\n        return { x: 0, y: 0 };\r\n    var _a = svgRef.current.getBoundingClientRect(), xarrowElemX = _a.left, xarrowElemY = _a.top;\r\n    var xarrowStyle = getComputedStyle(svgRef.current);\r\n    var xarrowStyleLeft = Number(xarrowStyle.left.slice(0, -2));\r\n    var xarrowStyleTop = Number(xarrowStyle.top.slice(0, -2));\r\n    return {\r\n        x: xarrowElemX - xarrowStyleLeft,\r\n        y: xarrowElemY - xarrowStyleTop,\r\n    };\r\n};\r\nexports.getSvgPos = getSvgPos;\r\n\n\n/***/ }),\n\n/***/ \"./src/Xwrapper.tsx\":\n/*!**************************!*\\\n  !*** ./src/Xwrapper.tsx ***!\n  \\**************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_55749__) {\n\n\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.XarrowContext = exports.XelemContext = void 0;\r\nvar react_1 = __importStar(__nested_webpack_require_55749__(/*! react */ \"react\"));\r\nexports.XelemContext = react_1.default.createContext(null);\r\nexports.XarrowContext = react_1.default.createContext(null);\r\nvar updateRef = {};\r\nvar updateRefCount = 0;\r\nvar log = console.log;\r\nvar XarrowProvider = function (_a) {\r\n    var children = _a.children, instanceCount = _a.instanceCount;\r\n    var _b = react_1.useState({}), setRender = _b[1];\r\n    var updateXarrow = function () { return setRender({}); };\r\n    react_1.useEffect(function () {\r\n        instanceCount.current = updateRefCount; // so this instance would know what is id\r\n        updateRef[instanceCount.current] = updateXarrow;\r\n    }, []);\r\n    // log('XarrowProvider', updateRefCount);\r\n    return react_1.default.createElement(exports.XarrowContext.Provider, { value: updateXarrow }, children);\r\n};\r\nvar XelemProvider = function (_a) {\r\n    var children = _a.children, instanceCount = _a.instanceCount;\r\n    return react_1.default.createElement(exports.XelemContext.Provider, { value: updateRef[instanceCount.current] }, children);\r\n};\r\nvar Xwrapper = function (_a) {\r\n    var children = _a.children;\r\n    var instanceCount = react_1.useRef(updateRefCount);\r\n    var _b = react_1.useState({}), setRender = _b[1];\r\n    react_1.useEffect(function () {\r\n        updateRefCount++;\r\n        setRender({});\r\n        return function () {\r\n            delete updateRef[instanceCount.current];\r\n        };\r\n    }, []);\r\n    return (react_1.default.createElement(XelemProvider, { instanceCount: instanceCount },\r\n        react_1.default.createElement(XarrowProvider, { instanceCount: instanceCount }, children)));\r\n};\r\nexports.default = Xwrapper;\r\n\n\n/***/ }),\n\n/***/ \"./src/constants.tsx\":\n/*!***************************!*\\\n  !*** ./src/constants.tsx ***!\n  \\***************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_58651__) {\n\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.cArrowShapes = exports.arrowShapes = exports.cSvgElems = exports.cPaths = exports.cAnchorEdge = void 0;\r\n// constants used for typescript and proptypes definitions\r\nvar react_1 = __importDefault(__nested_webpack_require_58651__(/*! react */ \"react\"));\r\nexports.cAnchorEdge = ['middle', 'left', 'right', 'top', 'bottom', 'auto'];\r\nexports.cPaths = ['smooth', 'grid', 'straight'];\r\nexports.cSvgElems = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'];\r\n//default arrows svgs\r\nexports.arrowShapes = {\r\n    arrow1: { svgElem: react_1.default.createElement(\"path\", { d: \"M 0 0 L 1 0.5 L 0 1 L 0.25 0.5 z\" }), offsetForward: 0.25 },\r\n    heart: {\r\n        svgElem: (react_1.default.createElement(\"path\", { d: \"M 0,0.25 A 0.125,0.125 0,0,1 0.5,0.25 A 0.125,0.125 0,0,1 1,0.25 Q 1,0.625 0.5,1 Q 0,0.625 0,0.25 z\" })),\r\n        offsetForward: 0.1,\r\n    },\r\n    circle: {\r\n        svgElem: react_1.default.createElement(\"circle\", { r: 0.5, cx: 0.5, cy: 0.5 }),\r\n        offsetForward: 0,\r\n    },\r\n};\r\nexports.cArrowShapes = Object.keys(exports.arrowShapes);\r\n\n\n/***/ }),\n\n/***/ \"./src/index.tsx\":\n/*!***********************!*\\\n  !*** ./src/index.tsx ***!\n  \\***********************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_60123__) {\n\n\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.useXarrow = exports.Xwrapper = exports.default = void 0;\r\nvar Xarrow_1 = __nested_webpack_require_60123__(/*! ./Xarrow/Xarrow */ \"./src/Xarrow/Xarrow.tsx\");\r\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return __importDefault(Xarrow_1).default; } }));\r\n__exportStar(__nested_webpack_require_60123__(/*! ./types */ \"./src/types.ts\"), exports);\r\n__exportStar(__nested_webpack_require_60123__(/*! ./constants */ \"./src/constants.tsx\"), exports);\r\nvar Xwrapper_1 = __nested_webpack_require_60123__(/*! ./Xwrapper */ \"./src/Xwrapper.tsx\");\r\nObject.defineProperty(exports, \"Xwrapper\", ({ enumerable: true, get: function () { return __importDefault(Xwrapper_1).default; } }));\r\nvar useXarrow_1 = __nested_webpack_require_60123__(/*! ./useXarrow */ \"./src/useXarrow.tsx\");\r\nObject.defineProperty(exports, \"useXarrow\", ({ enumerable: true, get: function () { return __importDefault(useXarrow_1).default; } }));\r\n\n\n/***/ }),\n\n/***/ \"./src/types.ts\":\n/*!**********************!*\\\n  !*** ./src/types.ts ***!\n  \\**********************/\n/***/ (function(__unused_webpack_module, exports) {\n\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n/***/ }),\n\n/***/ \"./src/useXarrow.tsx\":\n/*!***************************!*\\\n  !*** ./src/useXarrow.tsx ***!\n  \\***************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_62193__) {\n\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar react_1 = __nested_webpack_require_62193__(/*! react */ \"react\");\r\nvar Xwrapper_1 = __nested_webpack_require_62193__(/*! ./Xwrapper */ \"./src/Xwrapper.tsx\");\r\nvar useXarrow = function () {\r\n    var _a = react_1.useState({}), setRender = _a[1];\r\n    var reRender = function () { return setRender({}); };\r\n    var updateXarrow = react_1.useContext(Xwrapper_1.XelemContext);\r\n    if (!updateXarrow)\r\n        updateXarrow = function () { };\r\n    // throw new Error(\r\n    //   \"'Xwrapper' is required around element using 'useXarrow' hook! wrap your xarrows and connected elements with Xwrapper! \"\r\n    // );\r\n    react_1.useLayoutEffect(function () {\r\n        updateXarrow();\r\n    });\r\n    return reRender;\r\n};\r\nexports.default = useXarrow;\r\n\n\n/***/ }),\n\n/***/ \"lodash\":\n/*!*************************!*\\\n  !*** external \"lodash\" ***!\n  \\*************************/\n/***/ (function(module) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;\n\n/***/ }),\n\n/***/ \"prop-types\":\n/*!*****************************!*\\\n  !*** external \"prop-types\" ***!\n  \\*****************************/\n/***/ (function(module) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_prop_types__;\n\n/***/ }),\n\n/***/ \"react\":\n/*!************************!*\\\n  !*** external \"react\" ***!\n  \\************************/\n/***/ (function(module) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_63847__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_63847__);\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_63847__.c = __webpack_module_cache__;\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_63847__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_63847__.o(definition, key) && !__nested_webpack_require_63847__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_63847__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t!function() {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_63847__.r = function(exports) {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/node module decorator */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_63847__.nmd = function(module) {\n/******/ \t\t\tmodule.paths = [];\n/******/ \t\t\tif (!module.children) module.children = [];\n/******/ \t\t\treturn module;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// module cache are used so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_63847__(__nested_webpack_require_63847__.s = \"./src/index.tsx\");\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QteGFycm93cy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLHdHQUFPLEdBQUcsbUJBQU8sQ0FBQyxxREFBUSxHQUFHLG1CQUFPLENBQUMsNERBQVk7QUFDcEYsTUFBTSxFQUs2RTtBQUNuRixDQUFDO0FBQ0QsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQW1CLEVBQUUsK0JBQW1COztBQUVqRiwrQkFBbUIsR0FBRywwQkFBbUI7QUFDekMscUJBQXFCLCtCQUFtQixHQUFHLDBCQUFtQjtBQUM5RCxrREFBa0Qsa0NBQWtDO0FBQ3BGLHNEQUFzRDtBQUN0RCxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtCQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdELDJCQUEyQiwrQkFBbUI7QUFDOUMsdUNBQXVDLCtCQUFtQjtBQUMxRCxpQkFBaUIsK0JBQW1CO0FBQ3BDLGtDQUFrQywrQkFBbUI7QUFDckQsb0JBQW9CLCtCQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQywwQkFBMEIsWUFBWTtBQUN0Qyx1QkFBdUIsWUFBWTtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVksNEJBQTRCLGFBQWEsdUlBQXVJLEtBQUs7QUFDdk8sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsdUJBQXVCLGtCQUFrQixzQ0FBc0Msc0JBQXNCO0FBQ2pLLHdEQUF3RCw0REFBNEQscUhBQXFILHFDQUFxQztBQUM5USw2REFBNkQ7QUFDN0Qsb0NBQW9DO0FBQ3BDLCtGQUErRjtBQUMvRiw4TkFBOE4saUdBQWlHLGtFQUFrRSwwSUFBMEksMEdBQTBHLGdFQUFnRTtBQUNyckIsc0VBQXNFLG1LQUFtSztBQUN6TyxzRUFBc0U7QUFDdEUsc0JBQXNCO0FBQ3RCLHNPQUFzTztBQUN0TywyREFBMkQsMElBQTBJO0FBQ3JNO0FBQ0E7QUFDQSwwREFBMEQsaURBQWlEO0FBQzNHLDBEQUEwRCxnREFBZ0Q7QUFDMUcsd0RBQXdELGlIQUFpSDtBQUN6SywrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELGdDQUFnQyxnQ0FBbUI7QUFDbkQ7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25ELGdCQUFnQix1QkFBdUI7QUFDdkMsaUJBQWlCLDJCQUEyQjtBQUM1QyxlQUFlLHNCQUFzQjtBQUNyQyxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxnQ0FBbUIsR0FBRyxnQ0FBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdELG1DQUFtQyxnQ0FBbUI7QUFDdEQsa0JBQWtCLGdDQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5R0FBeUcsbUNBQW1DO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdELDJCQUEyQixnQ0FBbUI7QUFDOUMsY0FBYyxnQ0FBbUI7QUFDakMsK0JBQStCLGdDQUFtQjtBQUNsRCxrQkFBa0IsZ0NBQW1CO0FBQ3JDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0EsNkRBQTZELGdDQUFnQztBQUM3RjtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQixzQkFBc0I7QUFDakYsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUNoRSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUMsaURBQWlEO0FBQ2xGLCtCQUErQixpREFBaUQ7QUFDaEYscURBQXFELHNEQUFzRDtBQUMzRyxtREFBbUQsc0RBQXNEO0FBQ3pHLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQSxnREFBZ0QscUNBQXFDO0FBQ3JGLGdEQUFnRCxxQ0FBcUM7QUFDckYsZ0RBQWdELHFDQUFxQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5REFBeUQ7QUFDNUc7QUFDQSwrQ0FBK0MsNENBQTRDO0FBQzNGLHFDQUFxQyxrQ0FBa0M7QUFDdkUscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVMsNENBQTRDLHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0EsZ0JBQWdCLGdDQUFtQjtBQUNuQyxjQUFjLGdDQUFtQjtBQUNqQywrQkFBK0IsZ0NBQW1CO0FBQ2xELGtCQUFrQixnQ0FBbUI7QUFDckMsZ0JBQWdCLGdDQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdDQUFtQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBbUI7QUFDOUI7QUFDQSxnQkFBZ0IsZ0NBQW1CLHdCQUF3QixnQ0FBbUI7QUFDOUUsb0RBQW9ELHdDQUF3QztBQUM1RjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBbUIsMkJBQTJCO0FBQ3pELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQW1CLEdBQUcsZ0NBQW1CLENBQUMsZ0NBQW1CO0FBQzNFO0FBQ0EsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlhZ2VudC8uL25vZGVfbW9kdWxlcy9yZWFjdC14YXJyb3dzL2xpYi9pbmRleC5qcz85NTg2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoXCIpLCByZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInJlYWN0WGFycm93XCIsIFtcInJlYWN0XCIsIFwibG9kYXNoXCIsIFwicHJvcC10eXBlc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJyZWFjdFhhcnJvd1wiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoXCIpLCByZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVhY3RYYXJyb3dcIl0gPSBmYWN0b3J5KHJvb3RbXCJyZWFjdFwiXSwgcm9vdFtcImxvZGFzaFwiXSwgcm9vdFtcInByb3AtdHlwZXNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3Byb3BfdHlwZXNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL1hhcnJvdy91dGlscy9idXp6aWVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1hhcnJvdy91dGlscy9idXp6aWVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiYnpGdW5jdGlvblwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYnpGdW5jdGlvbjsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJidXp6aWVyTWluU29sc1wiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYnV6emllck1pblNvbHM7IH1cbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLy8gQnV6aWVyIGN1cnZlIGNhbGN1bGF0aW9uc1xuXG4vKipcclxuICogcmV0dXJucyBidXp6aWVyIGN1cnZlIGZ1bmN0aW9uIHdpdGggMiBjb250cm9scyBwb2ludHNcclxuICogYnpDdXJ2ZSB3aXRoIDIgY29udHJvbCBwb2ludHMgZnVuY3Rpb24oNCBwb2ludHMgdG90YWwpOiAgYnogPSAoMeKIknQpXjMqcDEgKyAzKDHiiJJ0KV4yKnQqcDIgKzMoMeKIknQpKnReMipwMyArIHReMypwNFxyXG4gKi9cbnZhciBiekZ1bmN0aW9uID0gZnVuY3Rpb24gYnpGdW5jdGlvbihwMSwgcDIsIHAzLCBwNCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMSAtIHQsIDMpICogcDEgKyAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHAyICsgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHAzICsgTWF0aC5wb3codCwgMykgKiBwNDtcbiAgfTtcbn07XG4vKipcclxuICogcmV0dXJucyAyIHNvbHV0aW9ucyBmcm9tIGV4dHJhbSBwb2ludHMgZm9yIGJ1enppZXIgY3VydmUgd2l0aCAyIGNvbnRyb2xzIHBvaW50c1xyXG4gKi9cblxudmFyIGJ1enppZXJNaW5Tb2xzID0gZnVuY3Rpb24gYnV6emllck1pblNvbHMocDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIGJ6ID0gYnpGdW5jdGlvbihwMSwgcDIsIHAzLCBwNCk7IC8vIGR0KGJ6KSA9IC0zIHAxICgxIC0gdCleMiArIDMgcDIgKDEgLSB0KV4yIC0gNiBwMiAoMSAtIHQpIHQgKyA2IHAzICgxIC0gdCkgdCAtIDMgcDMgdF4yICsgMyBwNCB0XjJcbiAgLy8gd2hlbiBwMT0oeDEseTEpLHAyPShjcHgxLGNweTEpLHAzPShjcHgyLGNweTIpLHA0PSh4Mix5MilcbiAgLy8gdGhlbiBleHRyZW1hIHBvaW50cyBpcyB3aGVuIGR0KGJ6KSA9IDBcbiAgLy8gc29sdXRpb25zID0+ICB0ID0gKCgtNiBwMSArIDEyIHAyIC0gNiBwMykgwrEgc3FydCgoNiBwMSAtIDEyIHAyICsgNiBwMyleMiAtIDQgKDMgcDIgLSAzIHAxKSAoLTMgcDEgKyA5IHAyIC0gOSBwMyArIDMgcDQpKSkvKDIgKC0zIHAxICsgOSBwMiAtIDkgcDMgKyAzIHA0KSkgIHdoZW4gKHAxICsgMyBwMyE9MyBwMiArIHA0KVxuICAvLyBpZiB3ZSBtYXJrIEE9KC02IHAxICsgMTIgcDIgLSA2IHAzKSBhbmQgQj0oNiBwMSAtIDEyIHAyICsgNiBwMyleMiAtIDQgKDMgcDIgLSAzIHAxKSAoLTMgcDEgKyA5IHAyIC0gOSBwMyArIDMgcDQpKSBhbmQgQyA9KDIgKC0zIHAxICsgOSBwMiAtIDkgcDMgKyAzIHA0KSB0aGVuXG4gIC8vIHRTb2wgPSBBIMKxIHNxcnQoQilcbiAgLy8gdGhlbiBzb2x1dGlvbiB3ZSB3YW50IGlzOiBieih0U29sKVxuXG4gIHZhciBBID0gLTYgKiBwMSArIDEyICogcDIgLSA2ICogcDM7XG4gIHZhciBCID0gTWF0aC5wb3coLTYgKiBwMSArIDEyICogcDIgLSA2ICogcDMsIDIpIC0gNCAqICgzICogcDIgLSAzICogcDEpICogKC0zICogcDEgKyA5ICogcDIgLSA5ICogcDMgKyAzICogcDQpO1xuICB2YXIgQyA9IDIgKiAoLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCk7XG4gIHZhciBzb2wxID0gYnooKEEgKyBNYXRoLnNxcnQoQikpIC8gQyk7XG4gIHZhciBzb2wyID0gYnooKEEgLSBNYXRoLnNxcnQoQikpIC8gQyk7XG4gIHJldHVybiBbc29sMSwgc29sMl07XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9YYXJyb3cvWGFycm93LnRzeFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9YYXJyb3cvWGFycm93LnRzeCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXCJyZWFjdFwiKSk7XHJcbnZhciB1c2VYYXJyb3dQcm9wc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXNlWGFycm93UHJvcHMgKi8gXCIuL3NyYy9YYXJyb3cvdXNlWGFycm93UHJvcHMudHNcIikpO1xyXG52YXIgWHdyYXBwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1h3cmFwcGVyICovIFwiLi9zcmMvWHdyYXBwZXIudHN4XCIpO1xyXG52YXIgcHJvcFR5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9wVHlwZXMgKi8gXCIuL3NyYy9YYXJyb3cvcHJvcFR5cGVzLnRzXCIpKTtcclxudmFyIEdldFBvc2l0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL0dldFBvc2l0aW9uICovIFwiLi9zcmMvWGFycm93L3V0aWxzL0dldFBvc2l0aW9uLnRzeFwiKTtcclxudmFyIGxvZyA9IGNvbnNvbGUubG9nO1xyXG52YXIgWGFycm93ID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAvLyBsb2coJ3hhcnJvdyB1cGRhdGUnKTtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBtYWluUmVmID0gcmVhY3RfMS51c2VSZWYoe1xyXG4gICAgICAgIHN2Z1JlZjogcmVhY3RfMS51c2VSZWYobnVsbCksXHJcbiAgICAgICAgbGluZVJlZjogcmVhY3RfMS51c2VSZWYobnVsbCksXHJcbiAgICAgICAgaGVhZFJlZjogcmVhY3RfMS51c2VSZWYobnVsbCksXHJcbiAgICAgICAgdGFpbFJlZjogcmVhY3RfMS51c2VSZWYobnVsbCksXHJcbiAgICAgICAgbGluZURyYXdBbmltUmVmOiByZWFjdF8xLnVzZVJlZihudWxsKSxcclxuICAgICAgICBsaW5lRGFzaEFuaW1SZWY6IHJlYWN0XzEudXNlUmVmKG51bGwpLFxyXG4gICAgICAgIGhlYWRPcGFjaXR5QW5pbVJlZjogcmVhY3RfMS51c2VSZWYobnVsbCksXHJcbiAgICB9KTtcclxuICAgIHZhciBfYiA9IG1haW5SZWYuY3VycmVudCwgc3ZnUmVmID0gX2Iuc3ZnUmVmLCBsaW5lUmVmID0gX2IubGluZVJlZiwgaGVhZFJlZiA9IF9iLmhlYWRSZWYsIHRhaWxSZWYgPSBfYi50YWlsUmVmLCBsaW5lRHJhd0FuaW1SZWYgPSBfYi5saW5lRHJhd0FuaW1SZWYsIGxpbmVEYXNoQW5pbVJlZiA9IF9iLmxpbmVEYXNoQW5pbVJlZiwgaGVhZE9wYWNpdHlBbmltUmVmID0gX2IuaGVhZE9wYWNpdHlBbmltUmVmO1xyXG4gICAgcmVhY3RfMS51c2VDb250ZXh0KFh3cmFwcGVyXzEuWGFycm93Q29udGV4dCk7XHJcbiAgICB2YXIgeFByb3BzID0gdXNlWGFycm93UHJvcHNfMS5kZWZhdWx0KHByb3BzLCBtYWluUmVmLmN1cnJlbnQpO1xyXG4gICAgdmFyIHByb3BzUmVmcyA9IHhQcm9wc1swXTtcclxuICAgIHZhciBsYWJlbHMgPSBwcm9wc1JlZnMubGFiZWxzLCBsaW5lQ29sb3IgPSBwcm9wc1JlZnMubGluZUNvbG9yLCBoZWFkQ29sb3IgPSBwcm9wc1JlZnMuaGVhZENvbG9yLCB0YWlsQ29sb3IgPSBwcm9wc1JlZnMudGFpbENvbG9yLCBzdHJva2VXaWR0aCA9IHByb3BzUmVmcy5zdHJva2VXaWR0aCwgc2hvd0hlYWQgPSBwcm9wc1JlZnMuc2hvd0hlYWQsIHNob3dUYWlsID0gcHJvcHNSZWZzLnNob3dUYWlsLCBkYXNobmVzcyA9IHByb3BzUmVmcy5kYXNobmVzcywgaGVhZFNoYXBlID0gcHJvcHNSZWZzLmhlYWRTaGFwZSwgdGFpbFNoYXBlID0gcHJvcHNSZWZzLnRhaWxTaGFwZSwgc2hvd1hhcnJvdyA9IHByb3BzUmVmcy5zaG93WGFycm93LCBhbmltYXRlRHJhd2luZyA9IHByb3BzUmVmcy5hbmltYXRlRHJhd2luZywgekluZGV4ID0gcHJvcHNSZWZzLnpJbmRleCwgcGFzc1Byb3BzID0gcHJvcHNSZWZzLnBhc3NQcm9wcywgYXJyb3dCb2R5UHJvcHMgPSBwcm9wc1JlZnMuYXJyb3dCb2R5UHJvcHMsIGFycm93SGVhZFByb3BzID0gcHJvcHNSZWZzLmFycm93SGVhZFByb3BzLCBhcnJvd1RhaWxQcm9wcyA9IHByb3BzUmVmcy5hcnJvd1RhaWxQcm9wcywgU1ZHY2FudmFzUHJvcHMgPSBwcm9wc1JlZnMuU1ZHY2FudmFzUHJvcHMsIGRpdkNvbnRhaW5lclByb3BzID0gcHJvcHNSZWZzLmRpdkNvbnRhaW5lclByb3BzLCBkaXZDb250YWluZXJTdHlsZSA9IHByb3BzUmVmcy5kaXZDb250YWluZXJTdHlsZSwgU1ZHY2FudmFzU3R5bGUgPSBwcm9wc1JlZnMuU1ZHY2FudmFzU3R5bGUsIF9kZWJ1ZyA9IHByb3BzUmVmcy5fZGVidWcsIHNob3VsZFVwZGF0ZVBvc2l0aW9uID0gcHJvcHNSZWZzLnNob3VsZFVwZGF0ZVBvc2l0aW9uO1xyXG4gICAgYW5pbWF0ZURyYXdpbmcgPSBwcm9wcy5hbmltYXRlRHJhd2luZztcclxuICAgIHZhciBfYyA9IHJlYWN0XzEudXNlU3RhdGUoIWFuaW1hdGVEcmF3aW5nKSwgZHJhd0FuaW1FbmRlZCA9IF9jWzBdLCBzZXREcmF3QW5pbUVuZGVkID0gX2NbMV07XHJcbiAgICB2YXIgX2QgPSByZWFjdF8xLnVzZVN0YXRlKHt9KSwgc2V0UmVuZGVyID0gX2RbMV07XHJcbiAgICB2YXIgZm9yY2VSZXJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFJlbmRlcih7fSk7IH07XHJcbiAgICB2YXIgX2UgPSByZWFjdF8xLnVzZVN0YXRlKHtcclxuICAgICAgICAvL2luaXRpYWwgc3RhdGVcclxuICAgICAgICBjeDA6IDAsXHJcbiAgICAgICAgY3kwOiAwLFxyXG4gICAgICAgIGN3OiAwLFxyXG4gICAgICAgIGNoOiAwLFxyXG4gICAgICAgIHgxOiAwLFxyXG4gICAgICAgIHkxOiAwLFxyXG4gICAgICAgIHgyOiAwLFxyXG4gICAgICAgIHkyOiAwLFxyXG4gICAgICAgIGR4OiAwLFxyXG4gICAgICAgIGR5OiAwLFxyXG4gICAgICAgIGFic0R4OiAwLFxyXG4gICAgICAgIGFic0R5OiAwLFxyXG4gICAgICAgIGNweDE6IDAsXHJcbiAgICAgICAgY3B5MTogMCxcclxuICAgICAgICBjcHgyOiAwLFxyXG4gICAgICAgIGNweTI6IDAsXHJcbiAgICAgICAgaGVhZE9yaWVudDogMCxcclxuICAgICAgICB0YWlsT3JpZW50OiAwLFxyXG4gICAgICAgIGFycm93SGVhZE9mZnNldDogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgYXJyb3dUYWlsT2Zmc2V0OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICBoZWFkT2Zmc2V0OiAwLFxyXG4gICAgICAgIGV4Y1JpZ2h0OiAwLFxyXG4gICAgICAgIGV4Y0xlZnQ6IDAsXHJcbiAgICAgICAgZXhjVXA6IDAsXHJcbiAgICAgICAgZXhjRG93bjogMCxcclxuICAgICAgICBzdGFydFBvaW50czogW10sXHJcbiAgICAgICAgZW5kUG9pbnRzOiBbXSxcclxuICAgICAgICBtYWluRGl2UG9zOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICB4U2lnbjogMSxcclxuICAgICAgICB5U2lnbjogMSxcclxuICAgICAgICBsaW5lTGVuZ3RoOiAwLFxyXG4gICAgICAgIGZIZWFkU2l6ZTogMSxcclxuICAgICAgICBmVGFpbFNpemU6IDEsXHJcbiAgICAgICAgYXJyb3dQYXRoOiBcIlwiLFxyXG4gICAgICAgIGxhYmVsU3RhcnRQb3M6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIGxhYmVsTWlkZGxlUG9zOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICBsYWJlbEVuZFBvczogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICB9KSwgc3QgPSBfZVswXSwgc2V0U3QgPSBfZVsxXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIE1haW4gbG9naWMgb2YgcGF0aCBjYWxjdWxhdGlvbiBmb3IgdGhlIGFycm93LlxyXG4gICAgICogY2FsY3VsYXRlIG5ldyBwYXRoLCBhZGp1c3RpbmcgY2FudmFzLCBhbmQgc2V0IHN0YXRlIGJhc2VkIG9uIGdpdmVuIHByb3BlcnRpZXMuXHJcbiAgICAgKiAqL1xyXG4gICAgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGxvZygneGFycm93IGdldFBvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBHZXRQb3NpdGlvbl8xLmdldFBvc2l0aW9uKHhQcm9wcywgbWFpblJlZik7XHJcbiAgICAgICAgICAgIC8vIGxvZygncG9zJywgcG9zKTtcclxuICAgICAgICAgICAgc2V0U3QocG9zKTtcclxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb24uY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gbG9nKCdzdCcsIHN0KTtcclxuICAgIHZhciB4T2Zmc2V0SGVhZCA9IHN0LngyIC0gc3QuYXJyb3dIZWFkT2Zmc2V0Lng7XHJcbiAgICB2YXIgeU9mZnNldEhlYWQgPSBzdC55MiAtIHN0LmFycm93SGVhZE9mZnNldC55O1xyXG4gICAgdmFyIHhPZmZzZXRUYWlsID0gc3QueDEgLSBzdC5hcnJvd1RhaWxPZmZzZXQueDtcclxuICAgIHZhciB5T2Zmc2V0VGFpbCA9IHN0LnkxIC0gc3QuYXJyb3dUYWlsT2Zmc2V0Lnk7XHJcbiAgICB2YXIgZGFzaG9mZnNldCA9IGRhc2huZXNzLnN0cm9rZUxlbiArIGRhc2huZXNzLm5vblN0cm9rZUxlbjtcclxuICAgIHZhciBhbmltRGlyZWN0aW9uID0gMTtcclxuICAgIGlmIChkYXNobmVzcy5hbmltYXRpb24gPCAwKSB7XHJcbiAgICAgICAgZGFzaG5lc3MuYW5pbWF0aW9uICo9IC0xO1xyXG4gICAgICAgIGFuaW1EaXJlY3Rpb24gPSAtMTtcclxuICAgIH1cclxuICAgIHZhciBkYXNoQXJyYXksIGFuaW1hdGlvbiwgYW5pbVJlcGVhdENvdW50LCBhbmltU3RhcnRWYWx1ZSwgYW5pbUVuZFZhbHVlID0gMDtcclxuICAgIGlmIChhbmltYXRlRHJhd2luZyAmJiBkcmF3QW5pbUVuZGVkID09IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbmltYXRlRHJhd2luZyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICBhbmltYXRlRHJhd2luZyA9IDE7XHJcbiAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0ZURyYXdpbmcgKyAncyc7XHJcbiAgICAgICAgZGFzaEFycmF5ID0gc3QubGluZUxlbmd0aDtcclxuICAgICAgICBhbmltU3RhcnRWYWx1ZSA9IHN0LmxpbmVMZW5ndGg7XHJcbiAgICAgICAgYW5pbVJlcGVhdENvdW50ID0gMTtcclxuICAgICAgICBpZiAoYW5pbWF0ZURyYXdpbmcgPCAwKSB7XHJcbiAgICAgICAgICAgIF9hID0gW2FuaW1FbmRWYWx1ZSwgYW5pbVN0YXJ0VmFsdWVdLCBhbmltU3RhcnRWYWx1ZSA9IF9hWzBdLCBhbmltRW5kVmFsdWUgPSBfYVsxXTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0ZURyYXdpbmcgKiAtMSArICdzJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkYXNoQXJyYXkgPSBkYXNobmVzcy5zdHJva2VMZW4gKyBcIiBcIiArIGRhc2huZXNzLm5vblN0cm9rZUxlbjtcclxuICAgICAgICBhbmltYXRpb24gPSAxIC8gZGFzaG5lc3MuYW5pbWF0aW9uICsgXCJzXCI7XHJcbiAgICAgICAgYW5pbVN0YXJ0VmFsdWUgPSBkYXNob2Zmc2V0ICogYW5pbURpcmVjdGlvbjtcclxuICAgICAgICBhbmltUmVwZWF0Q291bnQgPSAnaW5kZWZpbml0ZSc7XHJcbiAgICAgICAgYW5pbUVuZFZhbHVlID0gMDtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZSBkcmF3IGFuaW1hdGlvblxyXG4gICAgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsaW5lUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIHNldFN0KGZ1bmN0aW9uIChwcmV2U3QpIHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlN0KSwgeyBsaW5lTGVuZ3RoOiAoX2IgPSAoX2EgPSBsaW5lUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUb3RhbExlbmd0aCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwIH0pKTsgfSk7XHJcbiAgICB9LCBbbGluZVJlZi5jdXJyZW50XSk7XHJcbiAgICAvLyBzZXQgYWxsIHByb3BzIG9uIGZpcnN0IHJlbmRlclxyXG4gICAgcmVhY3RfMS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtb25pdG9yRE9NY2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZvcmNlUmVyZW5kZXIpO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlRHJhd0FtaW1FbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgc2V0RHJhd0FuaW1FbmRlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIChfYSA9IGhlYWRPcGFjaXR5QW5pbVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmVnaW5FbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICAoX2IgPSBsaW5lRGFzaEFuaW1SZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJlZ2luRWxlbWVudCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlRHJhd0FtaW1CZWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChoZWFkUmVmLmN1cnJlbnQuc3R5bGUub3BhY2l0eSA9ICcwJyk7IH07XHJcbiAgICAgICAgICAgIGlmIChsaW5lRHJhd0FuaW1SZWYuY3VycmVudCAmJiBoZWFkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVEcmF3QW5pbVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZEV2ZW50JywgaGFuZGxlRHJhd0FtaW1FbmQpO1xyXG4gICAgICAgICAgICAgICAgbGluZURyYXdBbmltUmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignYmVnaW5FdmVudCcsIGhhbmRsZURyYXdBbWltQmVnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZm9yY2VSZXJlbmRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZURyYXdBbmltUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRHJhd0FuaW1SZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRFdmVudCcsIGhhbmRsZURyYXdBbWltRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZFJlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRHJhd0FuaW1SZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWdpbkV2ZW50JywgaGFuZGxlRHJhd0FtaW1CZWdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2xlYW5Nb25pdG9yRE9NY2hhbmdlcyA9IG1vbml0b3JET01jaGFuZ2VzKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2V0RHJhd0FuaW1FbmRlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIGNsZWFuTW9uaXRvckRPTWNoYW5nZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3Nob3dYYXJyb3ddKTtcclxuICAgIC8vdG9kbzogY291bGQgbWFrZSBzb21lIGFkdmFuY2VkIGdlbmVyaWMgdHlwZXNjcmlwdCBpbmZlcnJpbmcuIGZvciBleGFtcGxlIGdldCB0eXBlIGZyb20gaGVhZFNoYXBlLmVsZW06VCBhbmRcclxuICAgIC8vIHRhaWxTaGFwZS5lbGVtOksgZm9yY2UgdGhlIHR5cGUgZm9yIHBhc3NQcm9wcyxhcnJvd0hlYWRQcm9wcyxhcnJvd1RhaWxQcm9wcyBwcm9wZXJ0eS4gZm9yIG5vdyBgYXMgYW55YCBpcyB1c2VkIHRvXHJcbiAgICAvLyBhdm9pZCB0eXBlc2NyaXB0IGNvbmZsaWN0c1xyXG4gICAgLy8gc28gdG9kby0gZml4IGFsbCB0aGUgYHBhc3NQcm9wcyBhcyBhbnlgIGFzc2VydGlvbnNcclxuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIGRpdkNvbnRhaW5lclByb3BzLCB7IHN0eWxlOiBfX2Fzc2lnbih7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB6SW5kZXg6IHpJbmRleCB9LCBkaXZDb250YWluZXJTdHlsZSkgfSksIHNob3dYYXJyb3cgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9fYXNzaWduKHsgcmVmOiBzdmdSZWYsIHdpZHRoOiBzdC5jdywgaGVpZ2h0OiBzdC5jaCwgc3R5bGU6IF9fYXNzaWduKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHN0LmN4MCwgdG9wOiBzdC5jeTAsIHBvaW50ZXJFdmVudHM6ICdub25lJywgYm9yZGVyOiBfZGVidWcgPyAnMXB4IGRhc2hlZCB5ZWxsb3cnIDogbnVsbCB9LCBTVkdjYW52YXNTdHlsZSksIG92ZXJmbG93OiBcImF1dG9cIiB9LCBTVkdjYW52YXNQcm9wcyksXHJcbiAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfX2Fzc2lnbih7IHJlZjogbGluZVJlZiwgZDogc3QuYXJyb3dQYXRoLCBzdHJva2U6IGxpbmVDb2xvciwgc3Ryb2tlRGFzaGFycmF5OiBkYXNoQXJyYXksIFxyXG4gICAgICAgICAgICAgICAgLy8gc3Ryb2tlRGFzaGFycmF5PXsnMCAwJ31cclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCwgZmlsbDogXCJ0cmFuc3BhcmVudFwiLCBwb2ludGVyRXZlbnRzOiBcInZpc2libGVTdHJva2VcIiB9LCBwYXNzUHJvcHMsIGFycm93Qm9keVByb3BzKSxcclxuICAgICAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0XzEuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgZHJhd0FuaW1FbmRlZCA/IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdF8xLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGRhc2huZXNzLmFuaW1hdGlvbiA/IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFuaW1hdGVcIiwgeyByZWY6IGxpbmVEYXNoQW5pbVJlZiwgYXR0cmlidXRlTmFtZTogXCJzdHJva2UtZGFzaG9mZnNldFwiLCB2YWx1ZXM6IGRhc2hvZmZzZXQgKiBhbmltRGlyZWN0aW9uICsgXCI7MFwiLCBkdXI6IDEgLyBkYXNobmVzcy5hbmltYXRpb24gKyBcInNcIiwgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiIH0pKSA6IG51bGwpKSA6IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdF8xLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGFuaW1hdGVEcmF3aW5nID8gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYW5pbWF0ZVwiLCB7IHJlZjogbGluZURyYXdBbmltUmVmLCBpZDogXCJzdmdFbmRBbmltYXRlXCIsIGF0dHJpYnV0ZU5hbWU6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgdmFsdWVzOiBhbmltU3RhcnRWYWx1ZSArIFwiO1wiICsgYW5pbUVuZFZhbHVlLCBkdXI6IGFuaW1hdGlvbiwgcmVwZWF0Q291bnQ6IGFuaW1SZXBlYXRDb3VudCB9KSkgOiBudWxsKSkpKSxcclxuICAgICAgICAgICAgc2hvd1RhaWwgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9fYXNzaWduKHsgZmlsbDogdGFpbENvbG9yLCBwb2ludGVyRXZlbnRzOiBcImF1dG9cIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXRUYWlsICsgXCIsXCIgKyB5T2Zmc2V0VGFpbCArIFwiKSByb3RhdGUoXCIgKyBzdC50YWlsT3JpZW50ICsgXCIpIHNjYWxlKFwiICsgc3QuZlRhaWxTaXplICsgXCIpXCIgfSwgcGFzc1Byb3BzLCBhcnJvd1RhaWxQcm9wcyksIHRhaWxTaGFwZS5zdmdFbGVtKSkgOiBudWxsLFxyXG4gICAgICAgICAgICBzaG93SGVhZCA/IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwgX19hc3NpZ24oeyByZWY6IGhlYWRSZWYsIFxyXG4gICAgICAgICAgICAgICAgLy8gZD17bm9ybWFsQXJyb3dTaGFwZX1cclxuICAgICAgICAgICAgICAgIGZpbGw6IGhlYWRDb2xvciwgcG9pbnRlckV2ZW50czogXCJhdXRvXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0SGVhZCArIFwiLFwiICsgeU9mZnNldEhlYWQgKyBcIikgcm90YXRlKFwiICsgc3QuaGVhZE9yaWVudCArIFwiKSBzY2FsZShcIiArIHN0LmZIZWFkU2l6ZSArIFwiKVwiLCBvcGFjaXR5OiBhbmltYXRlRHJhd2luZyAmJiAhZHJhd0FuaW1FbmRlZCA/IDAgOiAxIH0sIHBhc3NQcm9wcywgYXJyb3dIZWFkUHJvcHMpLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhbmltYXRlXCIsIHsgcmVmOiBoZWFkT3BhY2l0eUFuaW1SZWYsIGR1cjogJzAuNCcsIGF0dHJpYnV0ZU5hbWU6IFwib3BhY2l0eVwiLCBmcm9tOiBcIjBcIiwgdG86IFwiMVwiLCBiZWdpbjogXCJpbmRlZmluaXRlXCIsIHJlcGVhdENvdW50OiBcIjBcIiwgZmlsbDogXCJmcmVlemVcIiB9KSxcclxuICAgICAgICAgICAgICAgIGhlYWRTaGFwZS5zdmdFbGVtKSkgOiBudWxsLFxyXG4gICAgICAgICAgICBfZGVidWcgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyByOiBcIjVcIiwgY3g6IHN0LmNweDEsIGN5OiBzdC5jcHkxLCBmaWxsOiBcImdyZWVuXCIgfSksXHJcbiAgICAgICAgICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IHI6IFwiNVwiLCBjeDogc3QuY3B4MiwgY3k6IHN0LmNweTIsIGZpbGw6IFwiYmx1ZVwiIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHsgeDogc3QuZXhjTGVmdCwgeTogc3QuZXhjVXAsIHdpZHRoOiBzdC5hYnNEeCwgaGVpZ2h0OiBzdC5hYnNEeSwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJwaW5rXCIsIHN0cm9rZVdpZHRoOiBcIjJweFwiIH0pKSkgOiBudWxsKSxcclxuICAgICAgICBsYWJlbHMuc3RhcnQgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzdC5keCA8IDAgPyAndHJhbnNsYXRlKC0xMDAlICwgLTUwJSknIDogJ3RyYW5zbGF0ZSgtMCUgLCAtNTAlKScsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJ21heC1jb250ZW50JyxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogc3QuY3gwICsgc3QubGFiZWxTdGFydFBvcy54LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBzdC5jeTAgKyBzdC5sYWJlbFN0YXJ0UG9zLnkgLSBzdHJva2VXaWR0aCAtIDUsXHJcbiAgICAgICAgICAgIH0gfSwgbGFiZWxzLnN0YXJ0KSkgOiBudWxsLFxyXG4gICAgICAgIGxhYmVscy5taWRkbGUgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAnbWF4LWNvbnRlbnQnLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUgLCAtNTAlKScsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHN0LmN4MCArIHN0LmxhYmVsTWlkZGxlUG9zLngsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHN0LmN5MCArIHN0LmxhYmVsTWlkZGxlUG9zLnksXHJcbiAgICAgICAgICAgIH0gfSwgbGFiZWxzLm1pZGRsZSkpIDogbnVsbCxcclxuICAgICAgICBsYWJlbHMuZW5kID8gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc3QuZHggPiAwID8gJ3RyYW5zbGF0ZSgtMTAwJSAsIC01MCUpJyA6ICd0cmFuc2xhdGUoLTAlICwgLTUwJSknLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICdtYXgtY29udGVudCcsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHN0LmN4MCArIHN0LmxhYmVsRW5kUG9zLngsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHN0LmN5MCArIHN0LmxhYmVsRW5kUG9zLnkgKyBzdHJva2VXaWR0aCArIDUsXHJcbiAgICAgICAgICAgIH0gfSwgbGFiZWxzLmVuZCkpIDogbnVsbCxcclxuICAgICAgICBfZGVidWcgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHN0LnN0YXJ0UG9pbnRzKSwgc3QuZW5kUG9pbnRzKS5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnZ3JheScsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC41LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcC54IC0gc3QubWFpbkRpdlBvcy54LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcC55IC0gc3QubWFpbkRpdlBvcy55LFxyXG4gICAgICAgICAgICAgICAgfSB9KSk7XHJcbiAgICAgICAgfSkpKSA6IG51bGwpKSA6IG51bGwpKTtcclxufTtcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIHByb3BUeXBlc1xyXG5YYXJyb3cucHJvcFR5cGVzID0gcHJvcFR5cGVzXzEuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0ID0gWGFycm93O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvWGFycm93L2FuY2hvcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvWGFycm93L2FuY2hvcnMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIG1vZHVsZSBkZWNvcmF0b3IgKi8gbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQobW9kdWxlKTtcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcclxuZXhwb3J0cy5jYWxjQW5jaG9ycyA9IHZvaWQgMDtcclxudmFyIGdldEFuY2hvcnNEZWZhdWx0T2Zmc2V0cyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pZGRsZTogeyB4OiB3aWR0aCAqIDAuNSwgeTogaGVpZ2h0ICogMC41IH0sXHJcbiAgICAgICAgbGVmdDogeyB4OiAwLCB5OiBoZWlnaHQgKiAwLjUgfSxcclxuICAgICAgICByaWdodDogeyB4OiB3aWR0aCwgeTogaGVpZ2h0ICogMC41IH0sXHJcbiAgICAgICAgdG9wOiB7IHg6IHdpZHRoICogMC41LCB5OiAwIH0sXHJcbiAgICAgICAgYm90dG9tOiB7IHg6IHdpZHRoICogMC41LCB5OiBoZWlnaHQgfSxcclxuICAgIH07XHJcbn07XHJcbnZhciBjYWxjQW5jaG9ycyA9IGZ1bmN0aW9uIChhbmNob3JzLCBhbmNob3JQb3MpIHtcclxuICAgIC8vIG5vdyBwcmVwYXJlIHRoaXMgbGlzdCBvZiBhbmNob3JzIHRvIG9iamVjdCBleHBlY3RlZCBieSB0aGUgYGdldFNob3J0ZXN0TGluZWAgZnVuY3Rpb25cclxuICAgIHJldHVybiBhbmNob3JzLm1hcChmdW5jdGlvbiAoYW5jaG9yKSB7XHJcbiAgICAgICAgdmFyIGRlZnNPZmZzZXRzID0gZ2V0QW5jaG9yc0RlZmF1bHRPZmZzZXRzKGFuY2hvclBvcy5yaWdodCAtIGFuY2hvclBvcy54LCBhbmNob3JQb3MuYm90dG9tIC0gYW5jaG9yUG9zLnkpO1xyXG4gICAgICAgIHZhciBfYSA9IGRlZnNPZmZzZXRzW2FuY2hvci5wb3NpdGlvbl0sIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBhbmNob3JQb3MueCArIHggKyBhbmNob3Iub2Zmc2V0LngsXHJcbiAgICAgICAgICAgIHk6IGFuY2hvclBvcy55ICsgeSArIGFuY2hvci5vZmZzZXQueSxcclxuICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59O1xyXG5leHBvcnRzLmNhbGNBbmNob3JzID0gY2FsY0FuY2hvcnM7XHJcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmNbX193ZWJwYWNrX3JlcXVpcmVfXy5zXSA9PT0gbW9kdWxlKSB7XHJcbiAgICAvLyBjb25zdCByZXMgPSBwYXJzZUFuY2hvcihbJ2F1dG8nXSwge1xyXG4gICAgLy8gICB4OiAwLFxyXG4gICAgLy8gICB5OiAwLFxyXG4gICAgLy8gICBib3R0b206IDEwLFxyXG4gICAgLy8gICByaWdodDogMjAsXHJcbiAgICAvLyB9KTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHJlcyk7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1hhcnJvdy9wcm9wVHlwZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9YYXJyb3cvcHJvcFR5cGVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xyXG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHByb3AtdHlwZXMgKi8gXCJwcm9wLXR5cGVzXCIpKTtcclxudmFyIGNvbnN0YW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29uc3RhbnRzICovIFwiLi9zcmMvY29uc3RhbnRzLnRzeFwiKTtcclxudmFyIHBBbmNob3JQb3NpdGlvblR5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZihjb25zdGFudHNfMS5jQW5jaG9yRWRnZSk7XHJcbnZhciBwQW5jaG9yQ3VzdG9tUG9zaXRpb25UeXBlID0gcHJvcF90eXBlc18xLmRlZmF1bHQuZXhhY3Qoe1xyXG4gICAgcG9zaXRpb246IHBBbmNob3JQb3NpdGlvblR5cGUuaXNSZXF1aXJlZCxcclxuICAgIG9mZnNldDogcHJvcF90eXBlc18xLmRlZmF1bHQuZXhhY3Qoe1xyXG4gICAgICAgIHg6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcclxuICAgICAgICB5OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXHJcbiAgICB9KS5pc1JlcXVpcmVkLFxyXG59KTtcclxudmFyIF9wQW5jaG9yVHlwZSA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbcEFuY2hvclBvc2l0aW9uVHlwZSwgcEFuY2hvckN1c3RvbVBvc2l0aW9uVHlwZV0pO1xyXG52YXIgcEFuY2hvclR5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW19wQW5jaG9yVHlwZSwgcHJvcF90eXBlc18xLmRlZmF1bHQuYXJyYXlPZihfcEFuY2hvclR5cGUpXSk7XHJcbnZhciBwUmVmVHlwZSA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5leGFjdCh7IGN1cnJlbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSB9KV0pO1xyXG52YXIgX3BMYWJlbFR5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW3Byb3BfdHlwZXNfMS5kZWZhdWx0LmVsZW1lbnQsIHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZ10pO1xyXG52YXIgcExhYmVsc1R5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5leGFjdCh7XHJcbiAgICBzdGFydDogX3BMYWJlbFR5cGUsXHJcbiAgICBtaWRkbGU6IF9wTGFiZWxUeXBlLFxyXG4gICAgZW5kOiBfcExhYmVsVHlwZSxcclxufSk7XHJcbnZhciBwU3ZnRWRnZVNoYXBlVHlwZSA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mKE9iamVjdC5rZXlzKGNvbnN0YW50c18xLmFycm93U2hhcGVzKSk7XHJcbi8vIGNvbnN0IHBTdmdFbGVtVHlwZSA9IFBULm9uZU9mKGNTdmdFbGVtcyk7XHJcbnZhciBwU3ZnRWxlbVR5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5hbnk7XHJcbnZhciBwU3ZnRWRnZVR5cGUgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xyXG4gICAgcFN2Z0VkZ2VTaGFwZVR5cGUsXHJcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5leGFjdCh7XHJcbiAgICAgICAgc3ZnRWxlbTogcFN2Z0VsZW1UeXBlLFxyXG4gICAgICAgIG9mZnNldEZvcndhcmQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcclxuICAgIH0pLmlzUmVxdWlyZWQsXHJcbl0pO1xyXG52YXIgWGFycm93UHJvcFR5cGVzID0ge1xyXG4gICAgc3RhcnQ6IHBSZWZUeXBlLmlzUmVxdWlyZWQsXHJcbiAgICBlbmQ6IHBSZWZUeXBlLmlzUmVxdWlyZWQsXHJcbiAgICBzdGFydEFuY2hvcjogcEFuY2hvclR5cGUsXHJcbiAgICBlbmRBbmNob3I6IHBBbmNob3JUeXBlLFxyXG4gICAgbGFiZWxzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW19wTGFiZWxUeXBlLCBwTGFiZWxzVHlwZV0pLFxyXG4gICAgY29sb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcclxuICAgIGxpbmVDb2xvcjogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxyXG4gICAgc2hvd0hlYWQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXHJcbiAgICBoZWFkQ29sb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcclxuICAgIGhlYWRTaXplOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXHJcbiAgICB0YWlsU2l6ZTogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxyXG4gICAgdGFpbENvbG9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXHJcbiAgICBzdHJva2VXaWR0aDogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxyXG4gICAgc2hvd1RhaWw6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXHJcbiAgICBwYXRoOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZihjb25zdGFudHNfMS5jUGF0aHMpLFxyXG4gICAgc2hvd1hhcnJvdzogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcclxuICAgIGN1cnZlbmVzczogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxyXG4gICAgZ3JpZEJyZWFrOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXHJcbiAgICBkYXNobmVzczogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3RdKSxcclxuICAgIGhlYWRTaGFwZTogcFN2Z0VkZ2VUeXBlLFxyXG4gICAgdGFpbFNoYXBlOiBwU3ZnRWRnZVR5cGUsXHJcbiAgICBhbmltYXRlRHJhd2luZzogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXJdKSxcclxuICAgIHpJbmRleDogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxyXG4gICAgcGFzc1Byb3BzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXHJcbiAgICBhcnJvd0JvZHlQcm9wczogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxyXG4gICAgYXJyb3dIZWFkUHJvcHM6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcclxuICAgIGFycm93VGFpbFByb3BzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXHJcbiAgICBTVkdjYW52YXNQcm9wczogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxyXG4gICAgZGl2Q29udGFpbmVyUHJvcHM6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcclxuICAgIF9leHRlbmRTVkdjYW52YXM6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcclxuICAgIF9kZWJ1ZzogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcclxuICAgIF9jcHgxT2Zmc2V0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXHJcbiAgICBfY3B5MU9mZnNldDogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLFxyXG4gICAgX2NweDJPZmZzZXQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlcixcclxuICAgIF9jcHkyT2Zmc2V0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsXHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFhhcnJvd1Byb3BUeXBlcztcclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1hhcnJvdy91c2VYYXJyb3dQcm9wcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvWGFycm93L3VzZVhhcnJvd1Byb3BzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XHJcbnZhciByZWFjdF8xID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0ICovIFwicmVhY3RcIikpO1xyXG52YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXCIuL3NyYy9YYXJyb3cvdXRpbHMvaW5kZXgudHNcIik7XHJcbnZhciBsb2Rhc2hfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2ggKi8gXCJsb2Rhc2hcIikpO1xyXG52YXIgY29uc3RhbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25zdGFudHMgKi8gXCIuL3NyYy9jb25zdGFudHMudHN4XCIpO1xyXG52YXIgcGFyc2VMYWJlbHMgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgIHZhciBwYXJzZWRMYWJlbCA9IHsgc3RhcnQ6IG51bGwsIG1pZGRsZTogbnVsbCwgZW5kOiBudWxsIH07XHJcbiAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyB8fCByZWFjdF8xLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQobGFiZWwpKVxyXG4gICAgICAgICAgICBwYXJzZWRMYWJlbC5taWRkbGUgPSBsYWJlbDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWRMYWJlbFtrZXldID0gbGFiZWxba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRMYWJlbDtcclxufTtcclxudmFyIHBhcnNlQW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvcikge1xyXG4gICAgLy8gY29udmVydCB0byBhcnJheVxyXG4gICAgdmFyIGFuY2hvckNob2ljZSA9IEFycmF5LmlzQXJyYXkoYW5jaG9yKSA/IGFuY2hvciA6IFthbmNob3JdO1xyXG4gICAgLy9jb252ZXJ0IHRvIGFycmF5IG9mIG9iamVjdHNcclxuICAgIHZhciBhbmNob3JDaG9pY2UyID0gYW5jaG9yQ2hvaWNlLm1hcChmdW5jdGlvbiAoYW5jaG9yQ2hvaWNlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JDaG9pY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHBvc2l0aW9uOiBhbmNob3JDaG9pY2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yQ2hvaWNlO1xyXG4gICAgfSk7XHJcbiAgICAvL3JlbW92ZSBhbnkgaW52YWxpZCBhbmNob3IgbmFtZXNcclxuICAgIGFuY2hvckNob2ljZTIgPSBhbmNob3JDaG9pY2UyLmZpbHRlcihmdW5jdGlvbiAoYW4pIHsgcmV0dXJuIGNvbnN0YW50c18xLmNBbmNob3JFZGdlLmluY2x1ZGVzKGFuLnBvc2l0aW9uKTsgfSk7XHJcbiAgICBpZiAoYW5jaG9yQ2hvaWNlMi5sZW5ndGggPT0gMClcclxuICAgICAgICBhbmNob3JDaG9pY2UyID0gW3sgcG9zaXRpb246ICdhdXRvJyB9XTtcclxuICAgIC8vcmVwbGFjZSBhbnkgJ2F1dG8nIHdpdGggWydsZWZ0JywncmlnaHQnLCdib3R0b20nLCd0b3AnXVxyXG4gICAgdmFyIGF1dG9zQW5jcyA9IGFuY2hvckNob2ljZTIuZmlsdGVyKGZ1bmN0aW9uIChhbikgeyByZXR1cm4gYW4ucG9zaXRpb24gPT09ICdhdXRvJzsgfSk7XHJcbiAgICBpZiAoYXV0b3NBbmNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBhbmNob3JDaG9pY2UyID0gYW5jaG9yQ2hvaWNlMi5maWx0ZXIoZnVuY3Rpb24gKGFuKSB7IHJldHVybiBhbi5wb3NpdGlvbiAhPT0gJ2F1dG8nOyB9KTtcclxuICAgICAgICBhbmNob3JDaG9pY2UyLnB1c2guYXBwbHkoYW5jaG9yQ2hvaWNlMiwgYXV0b3NBbmNzLmZsYXRNYXAoZnVuY3Rpb24gKGFuY2hvck9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXS5tYXAoZnVuY3Rpb24gKGFuY2hvck5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYW5jaG9yT2JqKSwgeyBwb3NpdGlvbjogYW5jaG9yTmFtZSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgIHZhciBhbmNob3JDaG9pY2UzID0gYW5jaG9yQ2hvaWNlMi5tYXAoZnVuY3Rpb24gKGFuY2hvckNob2ljZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yQ2hvaWNlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yQ2hvaWNlQ3VzdG9tID0gYW5jaG9yQ2hvaWNlO1xyXG4gICAgICAgICAgICBpZiAoIWFuY2hvckNob2ljZUN1c3RvbS5wb3NpdGlvbilcclxuICAgICAgICAgICAgICAgIGFuY2hvckNob2ljZUN1c3RvbS5wb3NpdGlvbiA9ICdhdXRvJztcclxuICAgICAgICAgICAgaWYgKCFhbmNob3JDaG9pY2VDdXN0b20ub2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgYW5jaG9yQ2hvaWNlQ3VzdG9tLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgICAgICBpZiAoIWFuY2hvckNob2ljZUN1c3RvbS5vZmZzZXQueSlcclxuICAgICAgICAgICAgICAgIGFuY2hvckNob2ljZUN1c3RvbS5vZmZzZXQueSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghYW5jaG9yQ2hvaWNlQ3VzdG9tLm9mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgYW5jaG9yQ2hvaWNlQ3VzdG9tLm9mZnNldC54ID0gMDtcclxuICAgICAgICAgICAgYW5jaG9yQ2hvaWNlQ3VzdG9tID0gYW5jaG9yQ2hvaWNlQ3VzdG9tO1xyXG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yQ2hvaWNlQ3VzdG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBhbmNob3JDaG9pY2U7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhbmNob3JDaG9pY2UzO1xyXG59O1xyXG52YXIgcGFyc2VEYXNobmVzcyA9IGZ1bmN0aW9uIChkYXNobmVzcywgcHJvcHMpIHtcclxuICAgIHZhciBkYXNoU3Ryb2tlID0gMCwgZGFzaE5vbmUgPSAwLCBhbmltRGFzaFNwZWVkLCBhbmltRGlyZWN0aW9uID0gMTtcclxuICAgIGlmICh0eXBlb2YgZGFzaG5lc3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZGFzaFN0cm9rZSA9IGRhc2huZXNzLnN0cm9rZUxlbiB8fCBwcm9wcy5zdHJva2VXaWR0aCAqIDI7XHJcbiAgICAgICAgZGFzaE5vbmUgPSBkYXNobmVzcy5zdHJva2VMZW4gPyBkYXNobmVzcy5ub25TdHJva2VMZW4gOiBwcm9wcy5zdHJva2VXaWR0aDtcclxuICAgICAgICBhbmltRGFzaFNwZWVkID0gZGFzaG5lc3MuYW5pbWF0aW9uID8gZGFzaG5lc3MuYW5pbWF0aW9uIDogbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXNobmVzcyA9PT0gJ2Jvb2xlYW4nICYmIGRhc2huZXNzKSB7XHJcbiAgICAgICAgZGFzaFN0cm9rZSA9IHByb3BzLnN0cm9rZVdpZHRoICogMjtcclxuICAgICAgICBkYXNoTm9uZSA9IHByb3BzLnN0cm9rZVdpZHRoO1xyXG4gICAgICAgIGFuaW1EYXNoU3BlZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgc3Ryb2tlTGVuOiBkYXNoU3Ryb2tlLCBub25TdHJva2VMZW46IGRhc2hOb25lLCBhbmltYXRpb246IGFuaW1EYXNoU3BlZWQsIGFuaW1EaXJlY3Rpb246IGFuaW1EaXJlY3Rpb24gfTtcclxufTtcclxudmFyIHBhcnNlRWRnZVNoYXBlID0gZnVuY3Rpb24gKHN2Z0VkZ2UpIHtcclxuICAgIGlmICh0eXBlb2Ygc3ZnRWRnZSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChzdmdFZGdlIGluIGNvbnN0YW50c18xLmFycm93U2hhcGVzKVxyXG4gICAgICAgICAgICBzdmdFZGdlID0gY29uc3RhbnRzXzEuYXJyb3dTaGFwZXNbc3ZnRWRnZV07XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIidcIiArIHN2Z0VkZ2UgKyBcIicgaXMgbm90IHN1cHBvcnRlZCBhcnJvdyBzaGFwZS4gdGhlIHN1cHBvcnRlZCBhcnJvdyBzaGFwZXMgaXMgb25lIG9mIFwiICsgY29uc3RhbnRzXzEuY0Fycm93U2hhcGVzICsgXCIuXFxuICAgICAgICAgICByZXZlcnRpbmcgdG8gZGVmYXVsdCBzaGFwZS5cIik7XHJcbiAgICAgICAgICAgIHN2Z0VkZ2UgPSBjb25zdGFudHNfMS5hcnJvd1NoYXBlc1snYXJyb3cxJ107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3ZnRWRnZSA9IHN2Z0VkZ2U7XHJcbiAgICBpZiAoKHN2Z0VkZ2UgPT09IG51bGwgfHwgc3ZnRWRnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ZnRWRnZS5vZmZzZXRGb3J3YXJkKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHN2Z0VkZ2Uub2Zmc2V0Rm9yd2FyZCA9IDAuMjU7XHJcbiAgICBpZiAoKHN2Z0VkZ2UgPT09IG51bGwgfHwgc3ZnRWRnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ZnRWRnZS5zdmdFbGVtKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHN2Z0VkZ2Uuc3ZnRWxlbSA9ICdwYXRoJztcclxuICAgIC8vIGlmIChzdmdFZGdlPy5zdmdQcm9wcyA9PT0gdW5kZWZpbmVkKSBzdmdFZGdlLnN2Z1Byb3BzID0gYXJyb3dTaGFwZXMuYXJyb3cxLnN2Z1Byb3BzO1xyXG4gICAgcmV0dXJuIHN2Z0VkZ2U7XHJcbn07XHJcbnZhciBwYXJzZUdyaWRCcmVhayA9IGZ1bmN0aW9uIChncmlkQnJlYWspIHtcclxuICAgIHZhciByZXNHcmlkQnJlYWsgPSB1dGlsc18xLnhTdHIyYWJzUmVsYXRpdmUoZ3JpZEJyZWFrKTtcclxuICAgIGlmICghcmVzR3JpZEJyZWFrKVxyXG4gICAgICAgIHJlc0dyaWRCcmVhayA9IHsgcmVsYXRpdmU6IDAuNSwgYWJzOiAwIH07XHJcbiAgICByZXR1cm4gcmVzR3JpZEJyZWFrO1xyXG59O1xyXG4vKipcclxuICogc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCBhbnkgY2hhbmdlZCBwcm9wIHRoYXQgaXMgYWZmZWN0aW5nIHRoZSBwb2ludHMgcGF0aCBwb3NpdGlvbmluZ1xyXG4gKiBAcGFyYW0gcHJvcFZhbFxyXG4gKiBAcGFyYW0gdXBkYXRlUmVmXHJcbiAqL1xyXG52YXIgd2l0aFVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wVmFsLCB1cGRhdGVSZWYpIHtcclxuICAgIGlmICh1cGRhdGVSZWYpXHJcbiAgICAgICAgdXBkYXRlUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHByb3BWYWw7XHJcbn07XHJcbnZhciBub1BhcnNlID0gZnVuY3Rpb24gKHVzZXJQcm9wKSB7IHJldHVybiB1c2VyUHJvcDsgfTtcclxudmFyIG5vUGFyc2VXaXRoVXBkYXRlUG9zID0gZnVuY3Rpb24gKHVzZXJQcm9wLCBfLCB1cGRhdGVQb3MpIHsgcmV0dXJuIHdpdGhVcGRhdGUodXNlclByb3AsIHVwZGF0ZVBvcyk7IH07XHJcbnZhciBwYXJzZU51bVdpdGhVcGRhdGVQb3MgPSBmdW5jdGlvbiAodXNlclByb3AsIF8sIHVwZGF0ZVBvcykgeyByZXR1cm4gd2l0aFVwZGF0ZShOdW1iZXIodXNlclByb3ApLCB1cGRhdGVQb3MpOyB9O1xyXG52YXIgcGFyc2VOdW0gPSBmdW5jdGlvbiAodXNlclByb3ApIHsgcmV0dXJuIE51bWJlcih1c2VyUHJvcCk7IH07XHJcbnZhciBwYXJzZVByb3BzRnVuY3MgPSB7XHJcbiAgICBzdGFydDogZnVuY3Rpb24gKHVzZXJQcm9wKSB7IHJldHVybiB1dGlsc18xLmdldEVsZW1lbnRCeVByb3BHaXZlbih1c2VyUHJvcCk7IH0sXHJcbiAgICBlbmQ6IGZ1bmN0aW9uICh1c2VyUHJvcCkgeyByZXR1cm4gdXRpbHNfMS5nZXRFbGVtZW50QnlQcm9wR2l2ZW4odXNlclByb3ApOyB9LFxyXG4gICAgc3RhcnRBbmNob3I6IGZ1bmN0aW9uICh1c2VyUHJvcCwgXywgdXBkYXRlUG9zKSB7IHJldHVybiB3aXRoVXBkYXRlKHBhcnNlQW5jaG9yKHVzZXJQcm9wKSwgdXBkYXRlUG9zKTsgfSxcclxuICAgIGVuZEFuY2hvcjogZnVuY3Rpb24gKHVzZXJQcm9wLCBfLCB1cGRhdGVQb3MpIHsgcmV0dXJuIHdpdGhVcGRhdGUocGFyc2VBbmNob3IodXNlclByb3ApLCB1cGRhdGVQb3MpOyB9LFxyXG4gICAgbGFiZWxzOiBmdW5jdGlvbiAodXNlclByb3ApIHsgcmV0dXJuIHBhcnNlTGFiZWxzKHVzZXJQcm9wKTsgfSxcclxuICAgIGNvbG9yOiBub1BhcnNlLFxyXG4gICAgbGluZUNvbG9yOiBmdW5jdGlvbiAodXNlclByb3AsIHByb3BzUmVmcykgeyByZXR1cm4gdXNlclByb3AgfHwgcHJvcHNSZWZzLmNvbG9yOyB9LFxyXG4gICAgaGVhZENvbG9yOiBmdW5jdGlvbiAodXNlclByb3AsIHByb3BzUmVmcykgeyByZXR1cm4gdXNlclByb3AgfHwgcHJvcHNSZWZzLmNvbG9yOyB9LFxyXG4gICAgdGFpbENvbG9yOiBmdW5jdGlvbiAodXNlclByb3AsIHByb3BzUmVmcykgeyByZXR1cm4gdXNlclByb3AgfHwgcHJvcHNSZWZzLmNvbG9yOyB9LFxyXG4gICAgc3Ryb2tlV2lkdGg6IHBhcnNlTnVtV2l0aFVwZGF0ZVBvcyxcclxuICAgIHNob3dIZWFkOiBub1BhcnNlV2l0aFVwZGF0ZVBvcyxcclxuICAgIGhlYWRTaXplOiBwYXJzZU51bVdpdGhVcGRhdGVQb3MsXHJcbiAgICBzaG93VGFpbDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICB0YWlsU2l6ZTogcGFyc2VOdW1XaXRoVXBkYXRlUG9zLFxyXG4gICAgcGF0aDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBjdXJ2ZW5lc3M6IHBhcnNlTnVtV2l0aFVwZGF0ZVBvcyxcclxuICAgIGdyaWRCcmVhazogZnVuY3Rpb24gKHVzZXJQcm9wLCBfLCB1cGRhdGVQb3MpIHsgcmV0dXJuIHdpdGhVcGRhdGUocGFyc2VHcmlkQnJlYWsodXNlclByb3ApLCB1cGRhdGVQb3MpOyB9LFxyXG4gICAgLy8gLy8gZ3JpZFJhZGl1cyA9IHN0cm9rZVdpZHRoICogMiwgLy90b2RvXHJcbiAgICBkYXNobmVzczogZnVuY3Rpb24gKHVzZXJQcm9wLCBwcm9wc1JlZnMpIHsgcmV0dXJuIHBhcnNlRGFzaG5lc3ModXNlclByb3AsIHByb3BzUmVmcyk7IH0sXHJcbiAgICBoZWFkU2hhcGU6IGZ1bmN0aW9uICh1c2VyUHJvcCkgeyByZXR1cm4gcGFyc2VFZGdlU2hhcGUodXNlclByb3ApOyB9LFxyXG4gICAgdGFpbFNoYXBlOiBmdW5jdGlvbiAodXNlclByb3ApIHsgcmV0dXJuIHBhcnNlRWRnZVNoYXBlKHVzZXJQcm9wKTsgfSxcclxuICAgIHNob3dYYXJyb3c6IG5vUGFyc2UsXHJcbiAgICBhbmltYXRlRHJhd2luZzogbm9QYXJzZSxcclxuICAgIHpJbmRleDogcGFyc2VOdW0sXHJcbiAgICBwYXNzUHJvcHM6IG5vUGFyc2UsXHJcbiAgICBhcnJvd0JvZHlQcm9wczogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBhcnJvd0hlYWRQcm9wczogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBhcnJvd1RhaWxQcm9wczogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBTVkdjYW52YXNQcm9wczogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBkaXZDb250YWluZXJQcm9wczogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBkaXZDb250YWluZXJTdHlsZTogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBTVkdjYW52YXNTdHlsZTogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBfZXh0ZW5kU1ZHY2FudmFzOiBub1BhcnNlV2l0aFVwZGF0ZVBvcyxcclxuICAgIF9kZWJ1Zzogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBfY3B4MU9mZnNldDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBfY3B5MU9mZnNldDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBfY3B4Mk9mZnNldDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbiAgICBfY3B5Mk9mZnNldDogbm9QYXJzZVdpdGhVcGRhdGVQb3MsXHJcbn07XHJcbi8vYnVpbGQgZGVwZW5kZW5jaWVzXHJcbnZhciBwcm9wc0RlcHMgPSB7fTtcclxuLy9lYWNoIHByb3AgZGVwZW5kcyBvbiBoaW1zZWxmXHJcbmZvciAodmFyIHByb3BOYW1lIGluIHBhcnNlUHJvcHNGdW5jcykge1xyXG4gICAgcHJvcHNEZXBzW3Byb3BOYW1lXSA9IFtwcm9wTmFtZV07XHJcbn1cclxuLy8gJ2xpbmVDb2xvcicsICdoZWFkQ29sb3InLCAndGFpbENvbG9yJyBwcm9wcyBhbHNvIGRlcGVuZHMgb24gJ2NvbG9yJyBwcm9wXHJcbmZvciAodmFyIF9pID0gMCwgX2EgPSBbJ2xpbmVDb2xvcicsICdoZWFkQ29sb3InLCAndGFpbENvbG9yJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICB2YXIgcHJvcE5hbWUgPSBfYVtfaV07XHJcbiAgICBwcm9wc0RlcHNbcHJvcE5hbWVdLnB1c2goJ2NvbG9yJyk7XHJcbn1cclxudmFyIHBhcnNlR2l2ZW5Qcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgcHJvcHNSZWYpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3QuZW50cmllcyhwcm9wcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIF9jID0gX2JbX2ldLCBuYW1lXzEgPSBfY1swXSwgdmFsID0gX2NbMV07XHJcbiAgICAgICAgcHJvcHNSZWZbbmFtZV8xXSA9IChfYSA9IHBhcnNlUHJvcHNGdW5jcyA9PT0gbnVsbCB8fCBwYXJzZVByb3BzRnVuY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlUHJvcHNGdW5jc1tuYW1lXzFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwYXJzZVByb3BzRnVuY3MsIHZhbCwgcHJvcHNSZWYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzUmVmO1xyXG59O1xyXG52YXIgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgc3RhcnQ6IG51bGwsXHJcbiAgICBlbmQ6IG51bGwsXHJcbiAgICBzdGFydEFuY2hvcjogJ2F1dG8nLFxyXG4gICAgZW5kQW5jaG9yOiAnYXV0bycsXHJcbiAgICBsYWJlbHM6IG51bGwsXHJcbiAgICBjb2xvcjogJ0Nvcm5mbG93ZXJCbHVlJyxcclxuICAgIGxpbmVDb2xvcjogbnVsbCxcclxuICAgIGhlYWRDb2xvcjogbnVsbCxcclxuICAgIHRhaWxDb2xvcjogbnVsbCxcclxuICAgIHN0cm9rZVdpZHRoOiA0LFxyXG4gICAgc2hvd0hlYWQ6IHRydWUsXHJcbiAgICBoZWFkU2l6ZTogNixcclxuICAgIHNob3dUYWlsOiBmYWxzZSxcclxuICAgIHRhaWxTaXplOiA2LFxyXG4gICAgcGF0aDogJ3Ntb290aCcsXHJcbiAgICBjdXJ2ZW5lc3M6IDAuOCxcclxuICAgIGdyaWRCcmVhazogJzUwJScsXHJcbiAgICAvLyBncmlkUmFkaXVzIDogc3Ryb2tlV2lkdGggKiAyLCAvL3RvZG9cclxuICAgIGRhc2huZXNzOiBmYWxzZSxcclxuICAgIGhlYWRTaGFwZTogJ2Fycm93MScsXHJcbiAgICB0YWlsU2hhcGU6ICdhcnJvdzEnLFxyXG4gICAgc2hvd1hhcnJvdzogdHJ1ZSxcclxuICAgIGFuaW1hdGVEcmF3aW5nOiBmYWxzZSxcclxuICAgIHpJbmRleDogMCxcclxuICAgIHBhc3NQcm9wczoge30sXHJcbiAgICBhcnJvd0JvZHlQcm9wczoge30sXHJcbiAgICBhcnJvd0hlYWRQcm9wczoge30sXHJcbiAgICBhcnJvd1RhaWxQcm9wczoge30sXHJcbiAgICBTVkdjYW52YXNQcm9wczoge30sXHJcbiAgICBkaXZDb250YWluZXJQcm9wczoge30sXHJcbiAgICBkaXZDb250YWluZXJTdHlsZToge30sXHJcbiAgICBTVkdjYW52YXNTdHlsZToge30sXHJcbiAgICBfZXh0ZW5kU1ZHY2FudmFzOiAwLFxyXG4gICAgX2RlYnVnOiBmYWxzZSxcclxuICAgIF9jcHgxT2Zmc2V0OiAwLFxyXG4gICAgX2NweTFPZmZzZXQ6IDAsXHJcbiAgICBfY3B4Mk9mZnNldDogMCxcclxuICAgIF9jcHkyT2Zmc2V0OiAwLFxyXG59O1xyXG52YXIgaW5pdGlhbFBhcnNlZFByb3BzID0ge307XHJcbmluaXRpYWxQYXJzZWRQcm9wcyA9IHBhcnNlR2l2ZW5Qcm9wcyhkZWZhdWx0UHJvcHMsIGluaXRpYWxQYXJzZWRQcm9wcyk7XHJcbnZhciBpbml0aWFsVmFsVmFycyA9IHtcclxuICAgIHN0YXJ0UG9zOiB7IHg6IDAsIHk6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSxcclxuICAgIGVuZFBvczogeyB4OiAwLCB5OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH0sXHJcbn07XHJcbi8vIGNvbnN0IHBhcnNlQWxsUHJvcHMgPSAoKSA9PiBwYXJzZUdpdmVuUHJvcHMoZGVmYXVsdFByb3BzLCBpbml0aWFsUGFyc2VkUHJvcHMpO1xyXG5mdW5jdGlvbiBkZWVwQ29tcGFyZUVxdWFscyhhLCBiKSB7XHJcbiAgICByZXR1cm4gbG9kYXNoXzEuZGVmYXVsdC5pc0VxdWFsKGEsIGIpO1xyXG59XHJcbmZ1bmN0aW9uIHVzZURlZXBDb21wYXJlTWVtb2l6ZSh2YWx1ZSkge1xyXG4gICAgdmFyIHJlZiA9IHJlYWN0XzEudXNlUmVmKCk7XHJcbiAgICAvLyBpdCBjYW4gYmUgZG9uZSBieSB1c2luZyB1c2VNZW1vIGFzIHdlbGxcclxuICAgIC8vIGJ1dCB1c2VSZWYgaXMgcmF0aGVyIGNsZWFuZXIgYW5kIGVhc2llclxyXG4gICAgaWYgKCFkZWVwQ29tcGFyZUVxdWFscyh2YWx1ZSwgcmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWYuY3VycmVudDtcclxufVxyXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChjYWxsYmFjaywgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICByZWFjdF8xLnVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgZGVwZW5kZW5jaWVzLm1hcCh1c2VEZWVwQ29tcGFyZU1lbW9pemUpKTtcclxufVxyXG4vKipcclxuICogc21hcnQgaG9vayB0aGF0IHByb3ZpZGVzIHBhcnNlZCBwcm9wcyB0byBYYXJyb3cgYW5kIHdpbGwgdHJpZ2dlciByZXJlbmRlciB3aGVuZXZlciBnaXZlbiBwcm9wIGlzIGNoYW5nZWQuXHJcbiAqL1xyXG52YXIgdXNlWGFycm93UHJvcHMgPSBmdW5jdGlvbiAodXNlclByb3BzLCByZWZzKSB7XHJcbiAgICB2YXIgX2EgPSByZWFjdF8xLnVzZVN0YXRlKGluaXRpYWxQYXJzZWRQcm9wcyksIHByb3BzUmVmcyA9IF9hWzBdLCBzZXRQcm9wc1JlZnMgPSBfYVsxXTtcclxuICAgIHZhciBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IHJlYWN0XzEudXNlUmVmKGZhbHNlKTtcclxuICAgIC8vIGNvbnN0IF9wcm9wc1JlZnMgPSB1c2VSZWYoaW5pdGlhbFBhcnNlZFByb3BzKTtcclxuICAgIC8vIGNvbnN0IHByb3BzUmVmcyA9IF9wcm9wc1JlZnMuY3VycmVudDtcclxuICAgIHByb3BzUmVmc1snc2hvdWxkVXBkYXRlUG9zaXRpb24nXSA9IHNob3VsZFVwZGF0ZVBvc2l0aW9uO1xyXG4gICAgdmFyIGN1clByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRQcm9wcyksIHVzZXJQcm9wcyk7XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJlYWN0XzEudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBwcm9wc1JlZnNbcHJvcE5hbWVdID0gKF9hID0gcGFyc2VQcm9wc0Z1bmNzID09PSBudWxsIHx8IHBhcnNlUHJvcHNGdW5jcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VQcm9wc0Z1bmNzW3Byb3BOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocGFyc2VQcm9wc0Z1bmNzLCBjdXJQcm9wc1twcm9wTmFtZV0sIHByb3BzUmVmcywgc2hvdWxkVXBkYXRlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncHJvcCB1cGRhdGU6JywgcHJvcE5hbWUsICd3aXRoIHZhbHVlJywgcHJvcHNSZWZzW3Byb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIHNldFByb3BzUmVmcyhfX2Fzc2lnbih7fSwgcHJvcHNSZWZzKSk7XHJcbiAgICAgICAgfSwgcHJvcHNEZXBzW3Byb3BOYW1lXS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHVzZXJQcm9wc1tuYW1lXTsgfSkpO1xyXG4gICAgfTtcclxuICAgIC8vIHJlYWN0IHN0YXRlcyB0aGUgbnVtYmVyIG9mIGhvb2tzIHBlciByZW5kZXIgbXVzdCBzdGF5IGNvbnN0YW50LFxyXG4gICAgLy8gdGhpcyBpcyBvayB3ZSBhcmUgdXNpbmcgdGhlc2UgaG9va3MgaW4gYSBsb29wLCBiZWNhdXNlIHRoZSBudW1iZXIgb2YgcHJvcHMgaW4gZGVmYXVsdFByb3BzIGlzIGNvbnN0YW50LFxyXG4gICAgLy8gc28gdGhlIG51bWJlciBvZiBob29rIHdlIHdpbGwgZmlyZSBlYWNoIHJlbmRlciB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZS5cclxuICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIHJlZiB0aGF0IHJlcHJlc2VudHMgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcFxyXG4gICAgLy8gZm9yIGV4YW1wbGU6IGlmIGdpdmVuICdzdGFydCcgcHJvcCB3b3VsZCBjaGFuZ2UgY2FsbCBnZXRFbGVtZW50QnlQcm9wR2l2ZW4ocHJvcHMuc3RhcnQpIGFuZCBzYXZlIHZhbHVlIGludG8gcHJvcHNSZWZzLnN0YXJ0LmN1cnJlbnRcclxuICAgIC8vIHdoeSB0byBzYXZlIHJlZnMgdG8gcHJvcHMgcGFyc2VkIHZhbHVlcz8gc29tZSBvZiB0aGUgcHJvcHMgcmVxdWlyZSByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBjb21wdXRhdGlvbnMobGlrZSAnc3RhcnQnIGFuZCAnc3RhcnRBbmNob3InKS5cclxuICAgIC8vIHRoaXMgd2lsbCBhbHdheXMgcnVuIGluIHRoZSBzYW1lIG9yZGVyIGFuZCBUSEFUJ1MgV0FZIElUUyBMRUdBTFxyXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XHJcbiAgICAgICAgX2xvb3BfMShwcm9wTmFtZSk7XHJcbiAgICB9XHJcbiAgICAvLyByZXJlbmRlciB3aGVuZXZlciBwb3NpdGlvbiBvZiBzdGFydCBlbGVtZW50IG9yIGVuZCBlbGVtZW50IGNoYW5nZXNcclxuICAgIHZhciBfYiA9IHJlYWN0XzEudXNlU3RhdGUoaW5pdGlhbFZhbFZhcnMpLCB2YWxWYXJzID0gX2JbMF0sIHNldFZhbFZhcnMgPSBfYlsxXTtcclxuICAgIHZhciBzdGFydFBvcyA9IHV0aWxzXzEuZ2V0RWxlbVBvcyhwcm9wc1JlZnMuc3RhcnQpO1xyXG4gICAgdXNlRGVlcENvbXBhcmVFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhbFZhcnMuc3RhcnRQb3MgPSBzdGFydFBvcztcclxuICAgICAgICBzaG91bGRVcGRhdGVQb3NpdGlvbi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICBzZXRWYWxWYXJzKF9fYXNzaWduKHt9LCB2YWxWYXJzKSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0IHVwZGF0ZSBwb3MnLCBzdGFydFBvcyk7XHJcbiAgICB9LCBbc3RhcnRQb3NdKTtcclxuICAgIHZhciBlbmRQb3MgPSB1dGlsc18xLmdldEVsZW1Qb3MocHJvcHNSZWZzLmVuZCk7XHJcbiAgICB1c2VEZWVwQ29tcGFyZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFsVmFycy5lbmRQb3MgPSBlbmRQb3M7XHJcbiAgICAgICAgc2hvdWxkVXBkYXRlUG9zaXRpb24uY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgc2V0VmFsVmFycyhfX2Fzc2lnbih7fSwgdmFsVmFycykpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlbmQgdXBkYXRlIHBvcycsIGVuZFBvcyk7XHJcbiAgICB9LCBbZW5kUG9zXSk7XHJcbiAgICByZWFjdF8xLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3N2ZyBzaGFwZSBjaGFuZ2VkIScpO1xyXG4gICAgICAgIHNob3VsZFVwZGF0ZVBvc2l0aW9uLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHNldFZhbFZhcnMoX19hc3NpZ24oe30sIHZhbFZhcnMpKTtcclxuICAgIH0sIFtwcm9wc1JlZnMuaGVhZFNoYXBlLnN2Z0VsZW0sIHByb3BzUmVmcy50YWlsU2hhcGUuc3ZnRWxlbV0pO1xyXG4gICAgcmV0dXJuIFtwcm9wc1JlZnMsIHZhbFZhcnNdO1xyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VYYXJyb3dQcm9wcztcclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1hhcnJvdy91dGlscy9HZXRQb3NpdGlvbi50c3hcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9YYXJyb3cvdXRpbHMvR2V0UG9zaXRpb24udHN4ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xyXG5leHBvcnRzLmdldFBvc2l0aW9uID0gdm9pZCAwO1xyXG52YXIgYW5jaG9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vYW5jaG9ycyAqLyBcIi4vc3JjL1hhcnJvdy9hbmNob3JzLnRzXCIpO1xyXG52YXIgaW5kZXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5kZXggKi8gXCIuL3NyYy9YYXJyb3cvdXRpbHMvaW5kZXgudHNcIik7XHJcbnZhciBsb2Rhc2hfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2ggKi8gXCJsb2Rhc2hcIikpO1xyXG52YXIgY29uc3RhbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb25zdGFudHMgKi8gXCIuL3NyYy9jb25zdGFudHMudHN4XCIpO1xyXG52YXIgYnV6emllcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9idXp6aWVyICovIFwiLi9zcmMvWGFycm93L3V0aWxzL2J1enppZXIuanNcIik7XHJcbi8qKlxyXG4gKiBUaGUgTWFpbiBsb2dpYyBvZiBwYXRoIGNhbGN1bGF0aW9uIGZvciB0aGUgYXJyb3cuXHJcbiAqIGNhbGN1bGF0ZSBuZXcgcGF0aCwgYWRqdXN0aW5nIGNhbnZhcywgYW5kIHNldCBzdGF0ZSBiYXNlZCBvbiBnaXZlbiBwcm9wZXJ0aWVzLlxyXG4gKiAqL1xyXG52YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeFByb3BzLCBtYWluUmVmKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgdmFyIF9jLCBfZDtcclxuICAgIHZhciBwcm9wc1JlZnMgPSB4UHJvcHNbMF0sIHZhbFZhcnMgPSB4UHJvcHNbMV07XHJcbiAgICB2YXIgc3RhcnRBbmNob3IgPSBwcm9wc1JlZnMuc3RhcnRBbmNob3IsIGVuZEFuY2hvciA9IHByb3BzUmVmcy5lbmRBbmNob3IsIHN0cm9rZVdpZHRoID0gcHJvcHNSZWZzLnN0cm9rZVdpZHRoLCBzaG93SGVhZCA9IHByb3BzUmVmcy5zaG93SGVhZCwgaGVhZFNpemUgPSBwcm9wc1JlZnMuaGVhZFNpemUsIHNob3dUYWlsID0gcHJvcHNSZWZzLnNob3dUYWlsLCB0YWlsU2l6ZSA9IHByb3BzUmVmcy50YWlsU2l6ZSwgcGF0aCA9IHByb3BzUmVmcy5wYXRoLCBjdXJ2ZW5lc3MgPSBwcm9wc1JlZnMuY3VydmVuZXNzLCBncmlkQnJlYWsgPSBwcm9wc1JlZnMuZ3JpZEJyZWFrLCBoZWFkU2hhcGUgPSBwcm9wc1JlZnMuaGVhZFNoYXBlLCB0YWlsU2hhcGUgPSBwcm9wc1JlZnMudGFpbFNoYXBlLCBfZXh0ZW5kU1ZHY2FudmFzID0gcHJvcHNSZWZzLl9leHRlbmRTVkdjYW52YXMsIF9jcHgxT2Zmc2V0ID0gcHJvcHNSZWZzLl9jcHgxT2Zmc2V0LCBfY3B5MU9mZnNldCA9IHByb3BzUmVmcy5fY3B5MU9mZnNldCwgX2NweDJPZmZzZXQgPSBwcm9wc1JlZnMuX2NweDJPZmZzZXQsIF9jcHkyT2Zmc2V0ID0gcHJvcHNSZWZzLl9jcHkyT2Zmc2V0O1xyXG4gICAgdmFyIHN0YXJ0UG9zID0gdmFsVmFycy5zdGFydFBvcywgZW5kUG9zID0gdmFsVmFycy5lbmRQb3M7XHJcbiAgICB2YXIgX2UgPSBtYWluUmVmLmN1cnJlbnQsIHN2Z1JlZiA9IF9lLnN2Z1JlZiwgbGluZVJlZiA9IF9lLmxpbmVSZWY7XHJcbiAgICB2YXIgaGVhZE9yaWVudCA9IDA7XHJcbiAgICB2YXIgdGFpbE9yaWVudCA9IDA7XHJcbiAgICAvLyBjb252ZXJ0IHN0YXJ0QW5jaG9yIGFuZCBlbmRBbmNob3IgdG8gbGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudHMgYWxsb3dlZCBhbmNob3JzLlxyXG4gICAgdmFyIHN0YXJ0UG9pbnRzID0gYW5jaG9yc18xLmNhbGNBbmNob3JzKHN0YXJ0QW5jaG9yLCBzdGFydFBvcyk7XHJcbiAgICB2YXIgZW5kUG9pbnRzID0gYW5jaG9yc18xLmNhbGNBbmNob3JzKGVuZEFuY2hvciwgZW5kUG9zKTtcclxuICAgIC8vIGNob29zZSB0aGUgc21hbGxlc3QgcGF0aCBmb3IgMiBwb2ludHMgZnJvbSB0aGVzZSBwb3NzaWJpbGl0aWVzLlxyXG4gICAgdmFyIF9mID0gaW5kZXhfMS5nZXRTaG9ydGVzdExpbmUoc3RhcnRQb2ludHMsIGVuZFBvaW50cyksIGNob3NlblN0YXJ0ID0gX2YuY2hvc2VuU3RhcnQsIGNob3NlbkVuZCA9IF9mLmNob3NlbkVuZDtcclxuICAgIHZhciBzdGFydEFuY2hvclBvc2l0aW9uID0gY2hvc2VuU3RhcnQuYW5jaG9yLnBvc2l0aW9uLCBlbmRBbmNob3JQb3NpdGlvbiA9IGNob3NlbkVuZC5hbmNob3IucG9zaXRpb247XHJcbiAgICB2YXIgc3RhcnRQb2ludCA9IGxvZGFzaF8xLmRlZmF1bHQucGljayhjaG9zZW5TdGFydCwgWyd4JywgJ3knXSksIGVuZFBvaW50ID0gbG9kYXNoXzEuZGVmYXVsdC5waWNrKGNob3NlbkVuZCwgWyd4JywgJ3knXSk7XHJcbiAgICB2YXIgbWFpbkRpdlBvcyA9IGluZGV4XzEuZ2V0U3ZnUG9zKHN2Z1JlZik7XHJcbiAgICB2YXIgY3gwID0gTWF0aC5taW4oc3RhcnRQb2ludC54LCBlbmRQb2ludC54KSAtIG1haW5EaXZQb3MueDtcclxuICAgIHZhciBjeTAgPSBNYXRoLm1pbihzdGFydFBvaW50LnksIGVuZFBvaW50LnkpIC0gbWFpbkRpdlBvcy55O1xyXG4gICAgdmFyIGR4ID0gZW5kUG9pbnQueCAtIHN0YXJ0UG9pbnQueDtcclxuICAgIHZhciBkeSA9IGVuZFBvaW50LnkgLSBzdGFydFBvaW50Lnk7XHJcbiAgICB2YXIgYWJzRHggPSBNYXRoLmFicyhlbmRQb2ludC54IC0gc3RhcnRQb2ludC54KTtcclxuICAgIHZhciBhYnNEeSA9IE1hdGguYWJzKGVuZFBvaW50LnkgLSBzdGFydFBvaW50LnkpO1xyXG4gICAgdmFyIHhTaWduID0gZHggPiAwID8gMSA6IC0xO1xyXG4gICAgdmFyIHlTaWduID0gZHkgPiAwID8gMSA6IC0xO1xyXG4gICAgdmFyIF9nID0gW2hlYWRTaGFwZS5vZmZzZXRGb3J3YXJkLCB0YWlsU2hhcGUub2Zmc2V0Rm9yd2FyZF0sIGhlYWRPZmZzZXQgPSBfZ1swXSwgdGFpbE9mZnNldCA9IF9nWzFdO1xyXG4gICAgdmFyIGZIZWFkU2l6ZSA9IGhlYWRTaXplICogc3Ryb2tlV2lkdGg7IC8vZmFjdG9yZWQgaGVhZCBzaXplXHJcbiAgICB2YXIgZlRhaWxTaXplID0gdGFpbFNpemUgKiBzdHJva2VXaWR0aDsgLy9mYWN0b3JlZCBoZWFkIHNpemVcclxuICAgIC8vIGNvbnN0IHsgY3VycmVudDogX2hlYWRCb3ggfSA9IGhlYWRCb3g7XHJcbiAgICB2YXIgeEhlYWRPZmZzZXQgPSAwO1xyXG4gICAgdmFyIHlIZWFkT2Zmc2V0ID0gMDtcclxuICAgIHZhciB4VGFpbE9mZnNldCA9IDA7XHJcbiAgICB2YXIgeVRhaWxPZmZzZXQgPSAwO1xyXG4gICAgdmFyIF9oZWFkT2Zmc2V0ID0gZkhlYWRTaXplICogaGVhZE9mZnNldDtcclxuICAgIHZhciBfdGFpbE9mZnNldCA9IGZUYWlsU2l6ZSAqIHRhaWxPZmZzZXQ7XHJcbiAgICB2YXIgY3UgPSBOdW1iZXIoY3VydmVuZXNzKTtcclxuICAgIC8vIGdyaWRSYWRpdXMgPSBOdW1iZXIoZ3JpZFJhZGl1cyk7XHJcbiAgICBpZiAoIWNvbnN0YW50c18xLmNQYXRocy5pbmNsdWRlcyhwYXRoKSlcclxuICAgICAgICBwYXRoID0gJ3Ntb290aCc7XHJcbiAgICBpZiAocGF0aCA9PT0gJ3N0cmFpZ2h0Jykge1xyXG4gICAgICAgIGN1ID0gMDtcclxuICAgICAgICBwYXRoID0gJ3Ntb290aCc7XHJcbiAgICB9XHJcbiAgICB2YXIgYmlnZ2VyU2lkZSA9IGhlYWRTaXplID4gdGFpbFNpemUgPyBoZWFkU2l6ZSA6IHRhaWxTaXplO1xyXG4gICAgdmFyIF9jYWxjID0gc3Ryb2tlV2lkdGggKyAoc3Ryb2tlV2lkdGggKiBiaWdnZXJTaWRlKSAvIDI7XHJcbiAgICB2YXIgZXhjUmlnaHQgPSBfY2FsYztcclxuICAgIHZhciBleGNMZWZ0ID0gX2NhbGM7XHJcbiAgICB2YXIgZXhjVXAgPSBfY2FsYztcclxuICAgIHZhciBleGNEb3duID0gX2NhbGM7XHJcbiAgICBleGNMZWZ0ICs9IE51bWJlcihfZXh0ZW5kU1ZHY2FudmFzKTtcclxuICAgIGV4Y1JpZ2h0ICs9IE51bWJlcihfZXh0ZW5kU1ZHY2FudmFzKTtcclxuICAgIGV4Y1VwICs9IE51bWJlcihfZXh0ZW5kU1ZHY2FudmFzKTtcclxuICAgIGV4Y0Rvd24gKz0gTnVtYmVyKF9leHRlbmRTVkdjYW52YXMpO1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBhcnJvdyBwb2ludCB0byBwb2ludCBjYWxjdWxhdGlvbnNcclxuICAgIHZhciB4MSA9IDAsIHgyID0gYWJzRHgsIHkxID0gMCwgeTIgPSBhYnNEeTtcclxuICAgIGlmIChkeCA8IDApXHJcbiAgICAgICAgX2EgPSBbeDIsIHgxXSwgeDEgPSBfYVswXSwgeDIgPSBfYVsxXTtcclxuICAgIGlmIChkeSA8IDApXHJcbiAgICAgICAgX2IgPSBbeTIsIHkxXSwgeTEgPSBfYlswXSwgeTIgPSBfYlsxXTtcclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gYXJyb3cgY3VydmluZXNzIGFuZCBhcnJvd2hlYWQgcGxhY2VtZW50IGNhbGN1bGF0aW9uc1xyXG4gICAgaWYgKGN1ID09PSAwKSB7XHJcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBzdHJhaWdodCBwYXRoXHJcbiAgICAgICAgdmFyIGhlYWRBbmdlbCA9IE1hdGguYXRhbihhYnNEeSAvIGFic0R4KTtcclxuICAgICAgICBpZiAoc2hvd0hlYWQpIHtcclxuICAgICAgICAgICAgeDIgLT0gZkhlYWRTaXplICogKDEgLSBoZWFkT2Zmc2V0KSAqIHhTaWduICogTWF0aC5jb3MoaGVhZEFuZ2VsKTtcclxuICAgICAgICAgICAgeTIgLT0gZkhlYWRTaXplICogKDEgLSBoZWFkT2Zmc2V0KSAqIHlTaWduICogTWF0aC5zaW4oaGVhZEFuZ2VsKTtcclxuICAgICAgICAgICAgaGVhZEFuZ2VsICo9IHlTaWduO1xyXG4gICAgICAgICAgICBpZiAoeFNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgaGVhZEFuZ2VsID0gKE1hdGguUEkgLSBoZWFkQW5nZWwgKiB4U2lnbikgKiB4U2lnbjtcclxuICAgICAgICAgICAgeEhlYWRPZmZzZXQgPSBNYXRoLmNvcyhoZWFkQW5nZWwpICogX2hlYWRPZmZzZXQgLSAoTWF0aC5zaW4oaGVhZEFuZ2VsKSAqIGZIZWFkU2l6ZSkgLyAyO1xyXG4gICAgICAgICAgICB5SGVhZE9mZnNldCA9IChNYXRoLmNvcyhoZWFkQW5nZWwpICogZkhlYWRTaXplKSAvIDIgKyBNYXRoLnNpbihoZWFkQW5nZWwpICogX2hlYWRPZmZzZXQ7XHJcbiAgICAgICAgICAgIGhlYWRPcmllbnQgPSAoaGVhZEFuZ2VsICogMTgwKSAvIE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YWlsQW5nZWwgPSBNYXRoLmF0YW4oYWJzRHkgLyBhYnNEeCk7XHJcbiAgICAgICAgaWYgKHNob3dUYWlsKSB7XHJcbiAgICAgICAgICAgIHgxICs9IGZUYWlsU2l6ZSAqICgxIC0gdGFpbE9mZnNldCkgKiB4U2lnbiAqIE1hdGguY29zKHRhaWxBbmdlbCk7XHJcbiAgICAgICAgICAgIHkxICs9IGZUYWlsU2l6ZSAqICgxIC0gdGFpbE9mZnNldCkgKiB5U2lnbiAqIE1hdGguc2luKHRhaWxBbmdlbCk7XHJcbiAgICAgICAgICAgIHRhaWxBbmdlbCAqPSAteVNpZ247XHJcbiAgICAgICAgICAgIGlmICh4U2lnbiA+IDApXHJcbiAgICAgICAgICAgICAgICB0YWlsQW5nZWwgPSAoTWF0aC5QSSAtIHRhaWxBbmdlbCAqIHhTaWduKSAqIHhTaWduO1xyXG4gICAgICAgICAgICB4VGFpbE9mZnNldCA9IE1hdGguY29zKHRhaWxBbmdlbCkgKiBfdGFpbE9mZnNldCAtIChNYXRoLnNpbih0YWlsQW5nZWwpICogZlRhaWxTaXplKSAvIDI7XHJcbiAgICAgICAgICAgIHlUYWlsT2Zmc2V0ID0gKE1hdGguY29zKHRhaWxBbmdlbCkgKiBmVGFpbFNpemUpIC8gMiArIE1hdGguc2luKHRhaWxBbmdlbCkgKiBfdGFpbE9mZnNldDtcclxuICAgICAgICAgICAgdGFpbE9yaWVudCA9ICh0YWlsQW5nZWwgKiAxODApIC8gTWF0aC5QSTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBpbiBjYXNlIG9mIHNtb290aCBwYXRoXHJcbiAgICAgICAgaWYgKGVuZEFuY2hvclBvc2l0aW9uID09PSAnbWlkZGxlJykge1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIGEgbWlkZGxlIGFuY2hvciBpcyBjaG9zZW4gZm9yIGVuZEFuY2hvciBjaG9vc2UgZnJvbSB3aGljaCBzaWRlIHRvIGF0dGFjaCB0byB0aGUgbWlkZGxlIG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIGlmIChhYnNEeCA+IGFic0R5KSB7XHJcbiAgICAgICAgICAgICAgICBlbmRBbmNob3JQb3NpdGlvbiA9IHhTaWduID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuZEFuY2hvclBvc2l0aW9uID0geVNpZ24gPyAndG9wJyA6ICdib3R0b20nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG93SGVhZCkge1xyXG4gICAgICAgICAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5jbHVkZXMoZW5kQW5jaG9yUG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB4SGVhZE9mZnNldCArPSBfaGVhZE9mZnNldCAqIHhTaWduO1xyXG4gICAgICAgICAgICAgICAgeDIgLT0gZkhlYWRTaXplICogKDEgLSBoZWFkT2Zmc2V0KSAqIHhTaWduOyAvL3NhbWUhXHJcbiAgICAgICAgICAgICAgICB5SGVhZE9mZnNldCArPSAoZkhlYWRTaXplICogeFNpZ24pIC8gMjtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRBbmNob3JQb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZE9yaWVudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhTaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZE9yaWVudCArPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkT3JpZW50ID0gMTgwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4U2lnbiA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRPcmllbnQgKz0gMTgwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGVuZEFuY2hvclBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgeEhlYWRPZmZzZXQgKz0gKGZIZWFkU2l6ZSAqIC15U2lnbikgLyAyO1xyXG4gICAgICAgICAgICAgICAgeUhlYWRPZmZzZXQgKz0gX2hlYWRPZmZzZXQgKiB5U2lnbjtcclxuICAgICAgICAgICAgICAgIHkyIC09IGZIZWFkU2l6ZSAqIHlTaWduIC0geUhlYWRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kQW5jaG9yUG9zaXRpb24gPT09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZE9yaWVudCA9IDI3MDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeVNpZ24gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkT3JpZW50ICs9IDE4MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRPcmllbnQgPSA5MDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeVNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkT3JpZW50ICs9IDE4MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzaG93VGFpbCAmJiBjdSAhPT0gMCkge1xyXG4gICAgICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmNsdWRlcyhzdGFydEFuY2hvclBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICB4VGFpbE9mZnNldCArPSBfdGFpbE9mZnNldCAqIC14U2lnbjtcclxuICAgICAgICAgICAgeDEgKz0gZlRhaWxTaXplICogeFNpZ24gKyB4VGFpbE9mZnNldDtcclxuICAgICAgICAgICAgeVRhaWxPZmZzZXQgKz0gLShmVGFpbFNpemUgKiB4U2lnbikgLyAyO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRBbmNob3JQb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0YWlsT3JpZW50ID0gMTgwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhTaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0YWlsT3JpZW50ICs9IDE4MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhaWxPcmllbnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhTaWduID4gMClcclxuICAgICAgICAgICAgICAgICAgICB0YWlsT3JpZW50ICs9IDE4MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhzdGFydEFuY2hvclBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICB5VGFpbE9mZnNldCArPSBfdGFpbE9mZnNldCAqIC15U2lnbjtcclxuICAgICAgICAgICAgeTEgKz0gZlRhaWxTaXplICogeVNpZ24gKyB5VGFpbE9mZnNldDtcclxuICAgICAgICAgICAgeFRhaWxPZmZzZXQgKz0gKGZUYWlsU2l6ZSAqIHlTaWduKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChzdGFydEFuY2hvclBvc2l0aW9uID09PSAndG9wJykge1xyXG4gICAgICAgICAgICAgICAgdGFpbE9yaWVudCA9IDkwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHlTaWduID4gMClcclxuICAgICAgICAgICAgICAgICAgICB0YWlsT3JpZW50ICs9IDE4MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhaWxPcmllbnQgPSAyNzA7XHJcbiAgICAgICAgICAgICAgICBpZiAoeVNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRhaWxPcmllbnQgKz0gMTgwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGFycm93SGVhZE9mZnNldCA9IHsgeDogeEhlYWRPZmZzZXQsIHk6IHlIZWFkT2Zmc2V0IH07XHJcbiAgICB2YXIgYXJyb3dUYWlsT2Zmc2V0ID0geyB4OiB4VGFpbE9mZnNldCwgeTogeVRhaWxPZmZzZXQgfTtcclxuICAgIHZhciBjcHgxID0geDEsIGNweTEgPSB5MSwgY3B4MiA9IHgyLCBjcHkyID0geTI7XHJcbiAgICB2YXIgY3VydmVzUG9zc2liaWxpdGllcyA9IHt9O1xyXG4gICAgaWYgKHBhdGggPT09ICdzbW9vdGgnKVxyXG4gICAgICAgIGN1cnZlc1Bvc3NpYmlsaXRpZXMgPSB7XHJcbiAgICAgICAgICAgIGhoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvL2hvcml6b250YWwgLSBmcm9tIHJpZ2h0IHRvIGxlZnQgb3IgdGhlIG9wcG9zaXRlXHJcbiAgICAgICAgICAgICAgICBjcHgxICs9IGFic0R4ICogY3UgKiB4U2lnbjtcclxuICAgICAgICAgICAgICAgIGNweDIgLT0gYWJzRHggKiBjdSAqIHhTaWduO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB2djogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy92ZXJ0aWNhbCAtIGZyb20gdG9wIHRvIGJvdHRvbSBvciBvcHBvc2l0ZVxyXG4gICAgICAgICAgICAgICAgY3B5MSArPSBhYnNEeSAqIGN1ICogeVNpZ247XHJcbiAgICAgICAgICAgICAgICBjcHkyIC09IGFic0R5ICogY3UgKiB5U2lnbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaHY6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGhvcml6b250YWxseSB0aGVuIHZlcnRpY2FsbHlcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gdiBzaWRlIHRvIGggc2lkZVxyXG4gICAgICAgICAgICAgICAgY3B4MSArPSBhYnNEeCAqIGN1ICogeFNpZ247XHJcbiAgICAgICAgICAgICAgICBjcHkyIC09IGFic0R5ICogY3UgKiB5U2lnbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHZlcnRpY2FsbHkgdGhlbiBob3Jpem9udGFsbHlcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gaCBzaWRlIHRvIHYgc2lkZVxyXG4gICAgICAgICAgICAgICAgY3B5MSArPSBhYnNEeSAqIGN1ICogeVNpZ247XHJcbiAgICAgICAgICAgICAgICBjcHgyIC09IGFic0R4ICogY3UgKiB4U2lnbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgZWxzZSBpZiAocGF0aCA9PT0gJ2dyaWQnKSB7XHJcbiAgICAgICAgY3VydmVzUG9zc2liaWxpdGllcyA9IHtcclxuICAgICAgICAgICAgaGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNweDEgKz0gKGFic0R4ICogZ3JpZEJyZWFrLnJlbGF0aXZlICsgZ3JpZEJyZWFrLmFicykgKiB4U2lnbjtcclxuICAgICAgICAgICAgICAgIGNweDIgLT0gKGFic0R4ICogKDEgLSBncmlkQnJlYWsucmVsYXRpdmUpIC0gZ3JpZEJyZWFrLmFicykgKiB4U2lnbjtcclxuICAgICAgICAgICAgICAgIGlmIChzaG93SGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDEgLT0gKChmSGVhZFNpemUgKiAoMSAtIGhlYWRPZmZzZXQpKSAvIDIpICogeFNpZ247XHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MiArPSAoKGZIZWFkU2l6ZSAqICgxIC0gaGVhZE9mZnNldCkpIC8gMikgKiB4U2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaG93VGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDEgLT0gKChmVGFpbFNpemUgKiAoMSAtIHRhaWxPZmZzZXQpKSAvIDIpICogeFNpZ247XHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MiArPSAoKGZUYWlsU2l6ZSAqICgxIC0gdGFpbE9mZnNldCkpIC8gMikgKiB4U2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdnY6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNweTEgKz0gKGFic0R5ICogZ3JpZEJyZWFrLnJlbGF0aXZlICsgZ3JpZEJyZWFrLmFicykgKiB5U2lnbjtcclxuICAgICAgICAgICAgICAgIGNweTIgLT0gKGFic0R5ICogKDEgLSBncmlkQnJlYWsucmVsYXRpdmUpIC0gZ3JpZEJyZWFrLmFicykgKiB5U2lnbjtcclxuICAgICAgICAgICAgICAgIGlmIChzaG93SGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTEgLT0gKChmSGVhZFNpemUgKiAoMSAtIGhlYWRPZmZzZXQpKSAvIDIpICogeVNpZ247XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MiArPSAoKGZIZWFkU2l6ZSAqICgxIC0gaGVhZE9mZnNldCkpIC8gMikgKiB5U2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaG93VGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTEgLT0gKChmVGFpbFNpemUgKiAoMSAtIHRhaWxPZmZzZXQpKSAvIDIpICogeVNpZ247XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MiArPSAoKGZUYWlsU2l6ZSAqICgxIC0gdGFpbE9mZnNldCkpIC8gMikgKiB5U2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaHY6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNweDEgPSB4MjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNweTEgPSB5MjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gc21hcnQgc2VsZWN0IGJlc3QgY3VydmUgZm9yIHRoZSBjdXJyZW50IGFuY2hvcnNcclxuICAgIHZhciBzZWxlY3RlZEN1cnZpbmVzcyA9ICcnO1xyXG4gICAgaWYgKFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHN0YXJ0QW5jaG9yUG9zaXRpb24pKVxyXG4gICAgICAgIHNlbGVjdGVkQ3VydmluZXNzICs9ICdoJztcclxuICAgIGVsc2UgaWYgKFsnYm90dG9tJywgJ3RvcCddLmluY2x1ZGVzKHN0YXJ0QW5jaG9yUG9zaXRpb24pKVxyXG4gICAgICAgIHNlbGVjdGVkQ3VydmluZXNzICs9ICd2JztcclxuICAgIGVsc2UgaWYgKHN0YXJ0QW5jaG9yUG9zaXRpb24gPT09ICdtaWRkbGUnKVxyXG4gICAgICAgIHNlbGVjdGVkQ3VydmluZXNzICs9ICdtJztcclxuICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmNsdWRlcyhlbmRBbmNob3JQb3NpdGlvbikpXHJcbiAgICAgICAgc2VsZWN0ZWRDdXJ2aW5lc3MgKz0gJ2gnO1xyXG4gICAgZWxzZSBpZiAoWydib3R0b20nLCAndG9wJ10uaW5jbHVkZXMoZW5kQW5jaG9yUG9zaXRpb24pKVxyXG4gICAgICAgIHNlbGVjdGVkQ3VydmluZXNzICs9ICd2JztcclxuICAgIGVsc2UgaWYgKGVuZEFuY2hvclBvc2l0aW9uID09PSAnbWlkZGxlJylcclxuICAgICAgICBzZWxlY3RlZEN1cnZpbmVzcyArPSAnbSc7XHJcbiAgICBpZiAoYWJzRHggPiBhYnNEeSlcclxuICAgICAgICBzZWxlY3RlZEN1cnZpbmVzcyA9IHNlbGVjdGVkQ3VydmluZXNzLnJlcGxhY2UoL20vZywgJ2gnKTtcclxuICAgIGVsc2VcclxuICAgICAgICBzZWxlY3RlZEN1cnZpbmVzcyA9IHNlbGVjdGVkQ3VydmluZXNzLnJlcGxhY2UoL20vZywgJ3YnKTtcclxuICAgIGN1cnZlc1Bvc3NpYmlsaXRpZXNbc2VsZWN0ZWRDdXJ2aW5lc3NdKCk7XHJcbiAgICBjcHgxICs9IF9jcHgxT2Zmc2V0O1xyXG4gICAgY3B5MSArPSBfY3B5MU9mZnNldDtcclxuICAgIGNweDIgKz0gX2NweDJPZmZzZXQ7XHJcbiAgICBjcHkyICs9IF9jcHkyT2Zmc2V0O1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBjYW52YXMgc21hcnQgc2l6ZSBhZGp1c3RtZW50c1xyXG4gICAgdmFyIF9oID0gYnV6emllcl8xLmJ1enppZXJNaW5Tb2xzKHgxLCBjcHgxLCBjcHgyLCB4MiksIHhTb2wxID0gX2hbMF0sIHhTb2wyID0gX2hbMV07XHJcbiAgICB2YXIgX2ogPSBidXp6aWVyXzEuYnV6emllck1pblNvbHMoeTEsIGNweTEsIGNweTIsIHkyKSwgeVNvbDEgPSBfalswXSwgeVNvbDIgPSBfalsxXTtcclxuICAgIGlmICh4U29sMSA8IDApXHJcbiAgICAgICAgZXhjTGVmdCArPSAteFNvbDE7XHJcbiAgICBpZiAoeFNvbDIgPiBhYnNEeClcclxuICAgICAgICBleGNSaWdodCArPSB4U29sMiAtIGFic0R4O1xyXG4gICAgaWYgKHlTb2wxIDwgMClcclxuICAgICAgICBleGNVcCArPSAteVNvbDE7XHJcbiAgICBpZiAoeVNvbDIgPiBhYnNEeSlcclxuICAgICAgICBleGNEb3duICs9IHlTb2wyIC0gYWJzRHk7XHJcbiAgICBpZiAocGF0aCA9PT0gJ2dyaWQnKSB7XHJcbiAgICAgICAgZXhjTGVmdCArPSBfY2FsYztcclxuICAgICAgICBleGNSaWdodCArPSBfY2FsYztcclxuICAgICAgICBleGNVcCArPSBfY2FsYztcclxuICAgICAgICBleGNEb3duICs9IF9jYWxjO1xyXG4gICAgfVxyXG4gICAgeDEgKz0gZXhjTGVmdDtcclxuICAgIHgyICs9IGV4Y0xlZnQ7XHJcbiAgICB5MSArPSBleGNVcDtcclxuICAgIHkyICs9IGV4Y1VwO1xyXG4gICAgY3B4MSArPSBleGNMZWZ0O1xyXG4gICAgY3B4MiArPSBleGNMZWZ0O1xyXG4gICAgY3B5MSArPSBleGNVcDtcclxuICAgIGNweTIgKz0gZXhjVXA7XHJcbiAgICB2YXIgY3cgPSBhYnNEeCArIGV4Y0xlZnQgKyBleGNSaWdodCwgY2ggPSBhYnNEeSArIGV4Y1VwICsgZXhjRG93bjtcclxuICAgIGN4MCAtPSBleGNMZWZ0O1xyXG4gICAgY3kwIC09IGV4Y1VwO1xyXG4gICAgLy9sYWJlbHNcclxuICAgIHZhciBienggPSBidXp6aWVyXzEuYnpGdW5jdGlvbih4MSwgY3B4MSwgY3B4MiwgeDIpO1xyXG4gICAgdmFyIGJ6eSA9IGJ1enppZXJfMS5iekZ1bmN0aW9uKHkxLCBjcHkxLCBjcHkyLCB5Mik7XHJcbiAgICB2YXIgbGFiZWxTdGFydFBvcyA9IHsgeDogYnp4KDAuMDEpLCB5OiBienkoMC4wMSkgfTtcclxuICAgIHZhciBsYWJlbE1pZGRsZVBvcyA9IHsgeDogYnp4KDAuNSksIHk6IGJ6eSgwLjUpIH07XHJcbiAgICB2YXIgbGFiZWxFbmRQb3MgPSB7IHg6IGJ6eCgwLjk5KSwgeTogYnp5KDAuOTkpIH07XHJcbiAgICB2YXIgYXJyb3dQYXRoO1xyXG4gICAgaWYgKHBhdGggPT09ICdncmlkJykge1xyXG4gICAgICAgIC8vIHRvZG86IHN1cHBvcnQgZ3JpZFJhZGl1c1xyXG4gICAgICAgIC8vICBhcnJvd1BhdGggPSBgTSAke3gxfSAke3kxfSBMICAke2NweDEgLSAxMH0gJHtjcHkxfSBhMTAsMTAgMCAwIDEgMTAsMTBcclxuICAgICAgICAvLyBMICR7Y3B4Mn0gJHtjcHkyIC0gMTB9IGExMCwxMCAwIDAgMCAxMCwxMCBMICAke3gyfSAke3kyfWA7XHJcbiAgICAgICAgYXJyb3dQYXRoID0gXCJNIFwiICsgeDEgKyBcIiBcIiArIHkxICsgXCIgTCAgXCIgKyBjcHgxICsgXCIgXCIgKyBjcHkxICsgXCIgTCBcIiArIGNweDIgKyBcIiBcIiArIGNweTIgKyBcIiBcIiArIHgyICsgXCIgXCIgKyB5MjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICdzbW9vdGgnKVxyXG4gICAgICAgIGFycm93UGF0aCA9IFwiTSBcIiArIHgxICsgXCIgXCIgKyB5MSArIFwiIEMgXCIgKyBjcHgxICsgXCIgXCIgKyBjcHkxICsgXCIsIFwiICsgY3B4MiArIFwiIFwiICsgY3B5MiArIFwiLCBcIiArIHgyICsgXCIgXCIgKyB5MjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY3gwOiBjeDAsXHJcbiAgICAgICAgY3kwOiBjeTAsXHJcbiAgICAgICAgeDE6IHgxLFxyXG4gICAgICAgIHgyOiB4MixcclxuICAgICAgICB5MTogeTEsXHJcbiAgICAgICAgeTI6IHkyLFxyXG4gICAgICAgIGN3OiBjdyxcclxuICAgICAgICBjaDogY2gsXHJcbiAgICAgICAgY3B4MTogY3B4MSxcclxuICAgICAgICBjcHkxOiBjcHkxLFxyXG4gICAgICAgIGNweDI6IGNweDIsXHJcbiAgICAgICAgY3B5MjogY3B5MixcclxuICAgICAgICBkeDogZHgsXHJcbiAgICAgICAgZHk6IGR5LFxyXG4gICAgICAgIGFic0R4OiBhYnNEeCxcclxuICAgICAgICBhYnNEeTogYWJzRHksXHJcbiAgICAgICAgaGVhZE9yaWVudDogaGVhZE9yaWVudCxcclxuICAgICAgICB0YWlsT3JpZW50OiB0YWlsT3JpZW50LFxyXG4gICAgICAgIGxhYmVsU3RhcnRQb3M6IGxhYmVsU3RhcnRQb3MsXHJcbiAgICAgICAgbGFiZWxNaWRkbGVQb3M6IGxhYmVsTWlkZGxlUG9zLFxyXG4gICAgICAgIGxhYmVsRW5kUG9zOiBsYWJlbEVuZFBvcyxcclxuICAgICAgICBleGNMZWZ0OiBleGNMZWZ0LFxyXG4gICAgICAgIGV4Y1JpZ2h0OiBleGNSaWdodCxcclxuICAgICAgICBleGNVcDogZXhjVXAsXHJcbiAgICAgICAgZXhjRG93bjogZXhjRG93bixcclxuICAgICAgICBoZWFkT2Zmc2V0OiBfaGVhZE9mZnNldCxcclxuICAgICAgICBhcnJvd0hlYWRPZmZzZXQ6IGFycm93SGVhZE9mZnNldCxcclxuICAgICAgICBhcnJvd1RhaWxPZmZzZXQ6IGFycm93VGFpbE9mZnNldCxcclxuICAgICAgICBzdGFydFBvaW50czogc3RhcnRQb2ludHMsXHJcbiAgICAgICAgZW5kUG9pbnRzOiBlbmRQb2ludHMsXHJcbiAgICAgICAgbWFpbkRpdlBvczogbWFpbkRpdlBvcyxcclxuICAgICAgICB4U2lnbjogeFNpZ24sXHJcbiAgICAgICAgeVNpZ246IHlTaWduLFxyXG4gICAgICAgIGxpbmVMZW5ndGg6IChfZCA9IChfYyA9IGxpbmVSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFRvdGFsTGVuZ3RoKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDAsXHJcbiAgICAgICAgZkhlYWRTaXplOiBmSGVhZFNpemUsXHJcbiAgICAgICAgZlRhaWxTaXplOiBmVGFpbFNpemUsXHJcbiAgICAgICAgYXJyb3dQYXRoOiBhcnJvd1BhdGgsXHJcbiAgICB9O1xyXG59O1xyXG5leHBvcnRzLmdldFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9YYXJyb3cvdXRpbHMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL1hhcnJvdy91dGlscy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xyXG5leHBvcnRzLmdldFN2Z1BvcyA9IGV4cG9ydHMuZ2V0RWxlbVBvcyA9IGV4cG9ydHMuZ2V0U2hvcnRlc3RMaW5lID0gZXhwb3J0cy54U3RyMmFic1JlbGF0aXZlID0gZXhwb3J0cy5mYWN0b3JEcGF0aFN0ciA9IGV4cG9ydHMuZ2V0RWxlbWVudEJ5UHJvcEdpdmVuID0gdm9pZCAwO1xyXG52YXIgZ2V0RWxlbWVudEJ5UHJvcEdpdmVuID0gZnVuY3Rpb24gKHJlZikge1xyXG4gICAgdmFyIG15UmVmO1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gbXlSZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyZWYpO1xyXG4gICAgICAgIG15UmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVmKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBteVJlZiA9IHJlZiA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50O1xyXG4gICAgcmV0dXJuIG15UmVmO1xyXG59O1xyXG5leHBvcnRzLmdldEVsZW1lbnRCeVByb3BHaXZlbiA9IGdldEVsZW1lbnRCeVByb3BHaXZlbjtcclxuLy8gcmVjZWl2ZXMgc3RyaW5nIHJlcHJlc2VudGluZyBhIGQgcGF0aCBhbmQgZmFjdG9yaW5nIG9ubHkgdGhlIG51bWJlcnNcclxudmFyIGZhY3RvckRwYXRoU3RyID0gZnVuY3Rpb24gKGQsIGZhY3Rvcikge1xyXG4gICAgdmFyIGwgPSBkLnNwbGl0KC8oXFxkKyg/OlxcLlxcZCspPykvKTtcclxuICAgIGwgPSBsLm1hcChmdW5jdGlvbiAocykge1xyXG4gICAgICAgIGlmIChOdW1iZXIocykpXHJcbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKHMpICogZmFjdG9yKS50b1N0cmluZygpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsLmpvaW4oJycpO1xyXG59O1xyXG5leHBvcnRzLmZhY3RvckRwYXRoU3RyID0gZmFjdG9yRHBhdGhTdHI7XHJcbi8vIHJldHVybiByZWxhdGl2ZSxhYnNcclxudmFyIHhTdHIyYWJzUmVsYXRpdmUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIHsgYWJzOiAwLCByZWxhdGl2ZTogMC41IH07XHJcbiAgICB2YXIgc3AgPSBzdHIuc3BsaXQoJyUnKTtcclxuICAgIHZhciBhYnNMZW4gPSAwLCBwZXJjZW50TGVuID0gMDtcclxuICAgIGlmIChzcC5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHZhciBwID0gcGFyc2VGbG9hdChzcFswXSk7XHJcbiAgICAgICAgaWYgKCFpc05hTihwKSkge1xyXG4gICAgICAgICAgICBhYnNMZW4gPSBwO1xyXG4gICAgICAgICAgICByZXR1cm4geyBhYnM6IGFic0xlbiwgcmVsYXRpdmU6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzcC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgIHZhciBfYSA9IFtwYXJzZUZsb2F0KHNwWzBdKSwgcGFyc2VGbG9hdChzcFsxXSldLCBwMSA9IF9hWzBdLCBwMiA9IF9hWzFdO1xyXG4gICAgICAgIGlmICghaXNOYU4ocDEpKVxyXG4gICAgICAgICAgICBwZXJjZW50TGVuID0gcDEgLyAxMDA7XHJcbiAgICAgICAgaWYgKCFpc05hTihwMikpXHJcbiAgICAgICAgICAgIGFic0xlbiA9IHAyO1xyXG4gICAgICAgIGlmICghaXNOYU4ocDEpIHx8ICFpc05hTihwMikpXHJcbiAgICAgICAgICAgIHJldHVybiB7IGFiczogYWJzTGVuLCByZWxhdGl2ZTogcGVyY2VudExlbiB9O1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLnhTdHIyYWJzUmVsYXRpdmUgPSB4U3RyMmFic1JlbGF0aXZlO1xyXG52YXIgZGlzdCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcclxuICAgIC8vbGVuZ3RoIG9mIGxpbmVcclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKHAxLnggLSBwMi54KSwgMikgKyBNYXRoLnBvdygocDEueSAtIHAyLnkpLCAyKSk7XHJcbn07XHJcbnZhciBnZXRTaG9ydGVzdExpbmUgPSBmdW5jdGlvbiAoc1BvaW50cywgZVBvaW50cykge1xyXG4gICAgLy8gY2xvc2VzIHRQYWlyIE9mIFBvaW50cyB3aGljaCBmZWV0IHRvIHRoZSBzcGVjaWZpZWQgYW5jaG9yc1xyXG4gICAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eSwgZCA9IEluZmluaXR5O1xyXG4gICAgdmFyIGNsb3Nlc3RQYWlyO1xyXG4gICAgc1BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzcCkge1xyXG4gICAgICAgIGVQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoZXApIHtcclxuICAgICAgICAgICAgZCA9IGRpc3Qoc3AsIGVwKTtcclxuICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3RQYWlyID0geyBjaG9zZW5TdGFydDogc3AsIGNob3NlbkVuZDogZXAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2xvc2VzdFBhaXI7XHJcbn07XHJcbmV4cG9ydHMuZ2V0U2hvcnRlc3RMaW5lID0gZ2V0U2hvcnRlc3RMaW5lO1xyXG52YXIgZ2V0RWxlbVBvcyA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICBpZiAoIWVsZW0pXHJcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG4gICAgdmFyIHBvcyA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvcy5sZWZ0LFxyXG4gICAgICAgIHk6IHBvcy50b3AsXHJcbiAgICAgICAgcmlnaHQ6IHBvcy5yaWdodCxcclxuICAgICAgICBib3R0b206IHBvcy5ib3R0b20sXHJcbiAgICB9O1xyXG59O1xyXG5leHBvcnRzLmdldEVsZW1Qb3MgPSBnZXRFbGVtUG9zO1xyXG52YXIgZ2V0U3ZnUG9zID0gZnVuY3Rpb24gKHN2Z1JlZikge1xyXG4gICAgaWYgKCFzdmdSZWYuY3VycmVudClcclxuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XHJcbiAgICB2YXIgX2EgPSBzdmdSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeGFycm93RWxlbVggPSBfYS5sZWZ0LCB4YXJyb3dFbGVtWSA9IF9hLnRvcDtcclxuICAgIHZhciB4YXJyb3dTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoc3ZnUmVmLmN1cnJlbnQpO1xyXG4gICAgdmFyIHhhcnJvd1N0eWxlTGVmdCA9IE51bWJlcih4YXJyb3dTdHlsZS5sZWZ0LnNsaWNlKDAsIC0yKSk7XHJcbiAgICB2YXIgeGFycm93U3R5bGVUb3AgPSBOdW1iZXIoeGFycm93U3R5bGUudG9wLnNsaWNlKDAsIC0yKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHhhcnJvd0VsZW1YIC0geGFycm93U3R5bGVMZWZ0LFxyXG4gICAgICAgIHk6IHhhcnJvd0VsZW1ZIC0geGFycm93U3R5bGVUb3AsXHJcbiAgICB9O1xyXG59O1xyXG5leHBvcnRzLmdldFN2Z1BvcyA9IGdldFN2Z1BvcztcclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL1h3cmFwcGVyLnRzeFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvWHdyYXBwZXIudHN4ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xyXG5leHBvcnRzLlhhcnJvd0NvbnRleHQgPSBleHBvcnRzLlhlbGVtQ29udGV4dCA9IHZvaWQgMDtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXCJyZWFjdFwiKSk7XHJcbmV4cG9ydHMuWGVsZW1Db250ZXh0ID0gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmV4cG9ydHMuWGFycm93Q29udGV4dCA9IHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xyXG52YXIgdXBkYXRlUmVmID0ge307XHJcbnZhciB1cGRhdGVSZWZDb3VudCA9IDA7XHJcbnZhciBsb2cgPSBjb25zb2xlLmxvZztcclxudmFyIFhhcnJvd1Byb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaW5zdGFuY2VDb3VudCA9IF9hLmluc3RhbmNlQ291bnQ7XHJcbiAgICB2YXIgX2IgPSByZWFjdF8xLnVzZVN0YXRlKHt9KSwgc2V0UmVuZGVyID0gX2JbMV07XHJcbiAgICB2YXIgdXBkYXRlWGFycm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0UmVuZGVyKHt9KTsgfTtcclxuICAgIHJlYWN0XzEudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpbnN0YW5jZUNvdW50LmN1cnJlbnQgPSB1cGRhdGVSZWZDb3VudDsgLy8gc28gdGhpcyBpbnN0YW5jZSB3b3VsZCBrbm93IHdoYXQgaXMgaWRcclxuICAgICAgICB1cGRhdGVSZWZbaW5zdGFuY2VDb3VudC5jdXJyZW50XSA9IHVwZGF0ZVhhcnJvdztcclxuICAgIH0sIFtdKTtcclxuICAgIC8vIGxvZygnWGFycm93UHJvdmlkZXInLCB1cGRhdGVSZWZDb3VudCk7XHJcbiAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZXhwb3J0cy5YYXJyb3dDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1cGRhdGVYYXJyb3cgfSwgY2hpbGRyZW4pO1xyXG59O1xyXG52YXIgWGVsZW1Qcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGluc3RhbmNlQ291bnQgPSBfYS5pbnN0YW5jZUNvdW50O1xyXG4gICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGV4cG9ydHMuWGVsZW1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB1cGRhdGVSZWZbaW5zdGFuY2VDb3VudC5jdXJyZW50XSB9LCBjaGlsZHJlbik7XHJcbn07XHJcbnZhciBYd3JhcHBlciA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XHJcbiAgICB2YXIgaW5zdGFuY2VDb3VudCA9IHJlYWN0XzEudXNlUmVmKHVwZGF0ZVJlZkNvdW50KTtcclxuICAgIHZhciBfYiA9IHJlYWN0XzEudXNlU3RhdGUoe30pLCBzZXRSZW5kZXIgPSBfYlsxXTtcclxuICAgIHJlYWN0XzEudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVSZWZDb3VudCsrO1xyXG4gICAgICAgIHNldFJlbmRlcih7fSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZVJlZltpbnN0YW5jZUNvdW50LmN1cnJlbnRdO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFhlbGVtUHJvdmlkZXIsIHsgaW5zdGFuY2VDb3VudDogaW5zdGFuY2VDb3VudCB9LFxyXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFhhcnJvd1Byb3ZpZGVyLCB7IGluc3RhbmNlQ291bnQ6IGluc3RhbmNlQ291bnQgfSwgY2hpbGRyZW4pKSk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFh3cmFwcGVyO1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29uc3RhbnRzLnRzeFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnN0YW50cy50c3ggKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XHJcbmV4cG9ydHMuY0Fycm93U2hhcGVzID0gZXhwb3J0cy5hcnJvd1NoYXBlcyA9IGV4cG9ydHMuY1N2Z0VsZW1zID0gZXhwb3J0cy5jUGF0aHMgPSBleHBvcnRzLmNBbmNob3JFZGdlID0gdm9pZCAwO1xyXG4vLyBjb25zdGFudHMgdXNlZCBmb3IgdHlwZXNjcmlwdCBhbmQgcHJvcHR5cGVzIGRlZmluaXRpb25zXHJcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0ICovIFwicmVhY3RcIikpO1xyXG5leHBvcnRzLmNBbmNob3JFZGdlID0gWydtaWRkbGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ2F1dG8nXTtcclxuZXhwb3J0cy5jUGF0aHMgPSBbJ3Ntb290aCcsICdncmlkJywgJ3N0cmFpZ2h0J107XHJcbmV4cG9ydHMuY1N2Z0VsZW1zID0gWydjaXJjbGUnLCAnZWxsaXBzZScsICdsaW5lJywgJ3BhdGgnLCAncG9seWdvbicsICdwb2x5bGluZScsICdyZWN0J107XHJcbi8vZGVmYXVsdCBhcnJvd3Mgc3Znc1xyXG5leHBvcnRzLmFycm93U2hhcGVzID0ge1xyXG4gICAgYXJyb3cxOiB7IHN2Z0VsZW06IHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTSAwIDAgTCAxIDAuNSBMIDAgMSBMIDAuMjUgMC41IHpcIiB9KSwgb2Zmc2V0Rm9yd2FyZDogMC4yNSB9LFxyXG4gICAgaGVhcnQ6IHtcclxuICAgICAgICBzdmdFbGVtOiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNIDAsMC4yNSBBIDAuMTI1LDAuMTI1IDAsMCwxIDAuNSwwLjI1IEEgMC4xMjUsMC4xMjUgMCwwLDEgMSwwLjI1IFEgMSwwLjYyNSAwLjUsMSBRIDAsMC42MjUgMCwwLjI1IHpcIiB9KSksXHJcbiAgICAgICAgb2Zmc2V0Rm9yd2FyZDogMC4xLFxyXG4gICAgfSxcclxuICAgIGNpcmNsZToge1xyXG4gICAgICAgIHN2Z0VsZW06IHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgcjogMC41LCBjeDogMC41LCBjeTogMC41IH0pLFxyXG4gICAgICAgIG9mZnNldEZvcndhcmQ6IDAsXHJcbiAgICB9LFxyXG59O1xyXG5leHBvcnRzLmNBcnJvd1NoYXBlcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuYXJyb3dTaGFwZXMpO1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaW5kZXgudHN4XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50c3ggKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XHJcbmV4cG9ydHMudXNlWGFycm93ID0gZXhwb3J0cy5Yd3JhcHBlciA9IGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcclxudmFyIFhhcnJvd18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9YYXJyb3cvWGFycm93ICovIFwiLi9zcmMvWGFycm93L1hhcnJvdy50c3hcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoWGFycm93XzEpLmRlZmF1bHQ7IH0gfSkpO1xyXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcyAqLyBcIi4vc3JjL3R5cGVzLnRzXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzICovIFwiLi9zcmMvY29uc3RhbnRzLnRzeFwiKSwgZXhwb3J0cyk7XHJcbnZhciBYd3JhcHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Yd3JhcHBlciAqLyBcIi4vc3JjL1h3cmFwcGVyLnRzeFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWHdyYXBwZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoWHdyYXBwZXJfMSkuZGVmYXVsdDsgfSB9KSk7XHJcbnZhciB1c2VYYXJyb3dfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXNlWGFycm93ICovIFwiLi9zcmMvdXNlWGFycm93LnRzeFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlWGFycm93XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0KHVzZVhhcnJvd18xKS5kZWZhdWx0OyB9IH0pKTtcclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3VzZVhhcnJvdy50c3hcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91c2VYYXJyb3cudHN4ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xyXG52YXIgcmVhY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0ICovIFwicmVhY3RcIik7XHJcbnZhciBYd3JhcHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Yd3JhcHBlciAqLyBcIi4vc3JjL1h3cmFwcGVyLnRzeFwiKTtcclxudmFyIHVzZVhhcnJvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBfYSA9IHJlYWN0XzEudXNlU3RhdGUoe30pLCBzZXRSZW5kZXIgPSBfYVsxXTtcclxuICAgIHZhciByZVJlbmRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFJlbmRlcih7fSk7IH07XHJcbiAgICB2YXIgdXBkYXRlWGFycm93ID0gcmVhY3RfMS51c2VDb250ZXh0KFh3cmFwcGVyXzEuWGVsZW1Db250ZXh0KTtcclxuICAgIGlmICghdXBkYXRlWGFycm93KVxyXG4gICAgICAgIHVwZGF0ZVhhcnJvdyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8vIHRocm93IG5ldyBFcnJvcihcclxuICAgIC8vICAgXCInWHdyYXBwZXInIGlzIHJlcXVpcmVkIGFyb3VuZCBlbGVtZW50IHVzaW5nICd1c2VYYXJyb3cnIGhvb2shIHdyYXAgeW91ciB4YXJyb3dzIGFuZCBjb25uZWN0ZWQgZWxlbWVudHMgd2l0aCBYd3JhcHBlciEgXCJcclxuICAgIC8vICk7XHJcbiAgICByZWFjdF8xLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdXBkYXRlWGFycm93KCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZVJlbmRlcjtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlWGFycm93O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwibG9kYXNoXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwicHJvcC10eXBlc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwgXCJwcm9wLXR5cGVzXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcHJvcF90eXBlc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJyZWFjdFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwicmVhY3RcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubm1kID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0XHRtb2R1bGUucGF0aHMgPSBbXTtcbi8qKioqKiovIFx0XHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBtb2R1bGU7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHN4XCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-xarrows/lib/index.js\n");

/***/ })

};
;